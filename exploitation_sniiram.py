# -*- coding:utf-8 -*- 
'''
Created on 5 août 2014

@author: tvialette
'''

import numpy as np
import pandas as pd
from pandas import DataFrame
import re
import matplotlib.pyplot as plt

import display_and_graphs as dg
import load_data.medic_gouv as mg
from load_data.load import load_all
from display_and_graphs import info_display

# Numéro de la mise à jour pour la base medicaments.gouv
maj_gouv = 'maj_20140915122241'
# parametres du calcul
# Ne marche pas si la liste inclut 'CIS'
info_utiles_from_gouv = ['CIP7', 'CIP13', 'Nom', 'Id_Groupe', 'Prix',
                         'Code_Substance', 'Nom_Substance', 'Libelle_ASMR', 'Type',
                         'Date_declar_commerc', 'Date_AMM', 'Taux_rembours', 
                         'indic_droit_rembours', 'Statu_admin_presta',
                         'Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR',
                         'premiere_vente', 'derniere_vente']
info_utiles_from_cnamts = ['CIP', 'CODE_ATC', 'LABO', 'DOSAGE_SA', 'UNITE_SA', 'NB_UNITES'] #LABO

# Evite de recharger si on a déjà chargé la base.

def cip_unique(table):
    table['cip_unique'] = pd.Series([False] * len(table), index = table.index)
    code_substance_present = []
    i=0
    for cip in set(table['CIP13']):
        i+=1
        if i%100 == 0:
            print i
        test = table['CIP13'] == cip
        #S'il y a plus d'un médicament de même CIP13 dans la base
        if sum(test) != 1:
            trouve = False
            #Pour toutes les médicaments de même CIP
            for index in table[test].index:
                code = table.loc[index,'Code_Substance']
                # On cherche d'abord s'il y en a un dont la substance est déjà parmi les médicaments séléctionnés
                if code in code_substance_present:
                    table.loc[index, 'cip_unique'] = True
#                    test=~test
#                    test.loc[index] = True
#                    table = table[test]
                    trouve = True
                    break
            # Si on n'en trouve pas, on rajoute le premier de la liste aux médicaments séléctionnés
            if trouve == False:
                table.loc[index, 'cip_unique'] = True
#                index = table[test].index[0]
#                code = table.loc[index,'Code_Substance']
#                code_substance_present += [code]
#                test = ~test
#                test.loc[index] = True
#                table = table[test]
        else:
            table.loc[table['CIP13'] == cip, 'cip_unique'] = True
    return table
                
def groupe_substance_unique(table):
    group_select = table.groupby('Id_Groupe').apply(lambda x: len(set(x['Code_Substance'])) == 1)
    group_select_set = list(set(group_select.index[group_select]))
    table = table[table['Id_Groupe'].isin(group_select_set)]
    return table

'''Utile pour les graphs'''

##Quantité de prestations
#nombre_princeps = base_brute[base_brute['role']].groupby('group')[period].sum()
#nombre_generic = base_brute[~base_brute['role']].groupby('group')[period].sum()
#nombre_total = base_brute.groupby('group')[period].sum()
#
##Quantité de substance (en masse ou volume etc...) pour chaque groupe
#nombre_dosage_princeps = base_brute[base_brute['role']].groupby('group')[period].sum()
#nombre_dosage_generic = base_brute[~base_brute['role']].groupby('group')[period].sum()
#nombre_dosage_total = base_brute.groupby('group')[period].sum()
#
##Quantité moyenne sur un an de substance (en masse ou volume etc...) pour chaque groupe
#moving_average_princeps = dg.moving_average(nombre_princeps, 12)
#moving_average_generic = dg.moving_average(nombre_generic, 12)
#moving_average_total = dg.moving_average(nombre_total, 12)
#
## Différence des quantités de substancee vendue
#evolution_princeps = dg.evolution(select(nombre_princeps))
#evolution_generic = dg.evolution(select(nombre_generic))
#evolution_total = dg.evolution(select(nombre_total))
      
'''Modifient les prix pour une meilleure visualisation sur les graphs'''
def get_index(date):
    '''prend comme entrée une date au format YYYYMM et renvoie l'index numérique de cette date dans périod'''
    output = (int(date)/100-2003)*12 + int(date)%100-1
    return output
    
def rewrite_period_prix(ligne):
    '''sert dans la fonciont preparation_base_period_prix'''
    index = get_index(ligne['premiere_vente'])
    for i in range(index):
        ligne[period_prix_par_dosage[i]]=np.nan
        ligne[period_prix[i]]=np.nan
    return ligne
    
def preparation_base_period_prix(table):
    '''Remplace par des nan les valeurs prix avant que le médicament soit vendu (pour qu'il n'apparaisse pas dans les graphs)'''
    print 'actuellement dans preparation_base_period_prix'  
    table['premiere_vente'] = table['premiere_vente'].fillna(200301)
    table = table.apply(lambda x: rewrite_period_prix(x), axis = 1)
    return table

 
def calcul_prix_par_dosage_test(table, date = 201406):
    '''Calul du prix par dosage a une date précise pour les données issues de la base medic_gouv et cnamts'''
    print 'actuellement dans calcul_prix_par_dosage'
    string = 'prix_' + str(date)
    
    ### Pour la base medic_gouv
    table.loc[base_brute['Dosage']=='qs','Dosage']=0 #Cas particulier
    #base_brute['Dosage_num']=None
    table.loc[:,'Dosage_num'] = table['Dosage'].apply(lambda x: re.findall('\d*\.?\d+',str(x))[0])
    table['dosage_par_prestation_medic_gouv'] = [float(x) * float(y) for x,y in zip(table['Dosage_num'], base_brute['nb_ref_in_label_medic_gouv'])]
    table['dosage_par_prestation_medic_gouv'] = table['dosage_par_prestation_medic_gouv'].replace(0,np.nan)    
    table['prix_par_dosage_test_medic_gouv'] = [float(x) / float(y) for x,y in zip(table[string], table['dosage_par_prestation_medic_gouv'])]
    
    ### Pour la base cnamts
    table['dosage_par_prestation_cnamts'] = [float(x) * float(y) for x,y in zip(table['DOSAGE_SA'], table['NB_UNITES'])]
    table['prix_par_dosage_test_cnamts'] = [float(x) / float(y) for x,y in zip(table[string], table['dosage_par_prestation_cnamts'])]
    
    return table
    
    
def choix_de_la_base(table):
    '''Indique s'il faut conserver les valeurs du cnamts ou de médic. gouv pour chaque médicament'''
    print 'actuellement dans choix_de_la_base'
    table['base_choisie'] = None
    
    table.loc[table['prix_par_dosage_test_medic_gouv'] == 0, 'prix_par_dosage_test_medic_gouv'] = table.loc[table['prix_par_dosage_test_medic_gouv'] == 0, 'prix_par_dosage_test_medic_gouv'].apply(lambda x: np.nan)
    
    global taille_du_groupe
    global prix_moyen_par_groupe_medic_gouv
    global prix_moyen_par_groupe_cnamts
    global variance_par_groupe_medic_gouv
    global variance_par_groupe_cnamts
    taille_du_groupe = table.groupby('group').size()
    prix_moyen_par_groupe_medic_gouv = table.groupby('group')['prix_par_dosage_test_medic_gouv'].sum().div(taille_du_groupe)#.apply(lambda x: x*x) #Il s'agit en fait du carré
    prix_moyen_par_groupe_cnamts = table.groupby('group')['prix_par_dosage_test_cnamts'].sum().div(taille_du_groupe)#.apply(lambda x: x*x) #Il s'agit en fait du carré
#    prix_var_norm_par_groupe_medic_gouv = table.groupby('group')['prix_par_dosage_test_medic_gouv'].var().div(prix_moyen_par_groupe_medic_gouv)
#    prix_var_norm_par_groupe_cnamts = table.groupby('group')['prix_par_dosage_test_cnamts'].var().div(prix_moyen_par_groupe_cnamts)
    prix_var_norm_par_groupe_medic_gouv = table.groupby('group')['prix_par_dosage_test_medic_gouv'].std().div(prix_moyen_par_groupe_medic_gouv)
    prix_var_norm_par_groupe_cnamts = table.groupby('group')['prix_par_dosage_test_cnamts'].std().div(prix_moyen_par_groupe_cnamts)    
    
    #On conserve les prix dans la même base si on a tous les prix d'un groupe
#    a = table.groupby('group')['prix_par_dosage_test_medic_gouv'].count(np.nan) == 0 # on repere les groupe sans missng value
#    b = table.groupby('group')['prix_par_dosage_test_cnamts'].count(np.nan) == 0 # on repere les groupe sans missing value
    a = ~prix_moyen_par_groupe_medic_gouv.isnull()
    b = ~prix_moyen_par_groupe_cnamts.isnull()
    #print('a')
    #Pour chaque groupe
    i=0
    for group in set(table['group']):
        if i%100 == 0:
            print str(float(i) / float(len(set(table['group'])))) + '%'
        i=i+1
        # Dans le cas où les valeurs de prix pour tout le groupe dans les deux base
        if a[group] and b[group]:
            #print('b')
            # On garde le groupe avec la variance normalisée la plus faible
            if prix_var_norm_par_groupe_medic_gouv[group] < prix_var_norm_par_groupe_cnamts[group]:
                table.loc[base_brute['group'] == group,'base_choisie'] = 'medic_gouv'
            else:
                table.loc[base_brute['group'] == group,'base_choisie'] = 'cnamts'
        elif a[group]:
            #print('c')
            table.loc[base_brute['group'] == group,'base_choisie'] = 'medic_gouv'
        elif b[group]:
            #print('d')
            table.loc[base_brute['group'] == group,'base_choisie'] = 'cnamts'
        else:
            #print('e')
            #Enfin, si on a deux valeurs différentes, on calcule le prix relativement à la moyenne du groupe.
            # Le prix "moyen" est en réalité la somme des prix mais ca n'a pas de conséquences
            table[table['base_choisie'].isnull()] = table[table['base_choisie'].isnull()].apply(lambda x: choix_de_la_base_lambda1(x), axis=1)            
            #print('f')
            table[table['base_choisie'].isnull()] = table[table['base_choisie'].isnull()].apply(lambda x: choix_de_la_base_lambda2(x), axis = 1)
    return table  
     
def choix_de_la_base_lambda1(ligne):
    if ligne['prix_par_dosage_test_medic_gouv'] == 0:
        ligne['prix_par_dosage_test_medic_gouv'] = np.nan
    if sum(ligne[['prix_par_dosage_test_medic_gouv', 'prix_par_dosage_test_cnamts']].isnull()) == 2:
        ligne['base_choisie'] = 'Aucune'
    elif sum(ligne[['prix_par_dosage_test_medic_gouv', 'prix_par_dosage_test_cnamts']].isnull()) == 1:
        if np.isnan(ligne['prix_par_dosage_test_medic_gouv']):
            ligne['base_choisie'] = 'cnamts'
        else:
            ligne['base_choisie'] = 'medic_gouv'
    elif ligne['prix_par_dosage_test_medic_gouv'] == ligne['prix_par_dosage_test_cnamts']:
        ligne['base_choisie'] = 'medic_gouv'
    
    return ligne
    
    
def choix_de_la_base_lambda2(ligne):
    # On choisit la base qui donne un ratio le plus petit possible (équivalent écart à la moyenne)
    #print (prix_moyen_par_groupe_medic_gouv[ligne['Id_Groupe']])
    #if taille_du_groupe[ligne['group']] <=2:
    #    ligne['base_choisie'] = 'medic_gouv'
    
    ratio_medic_gouv = ligne['prix_par_dosage_test_medic_gouv'] / float(prix_moyen_par_groupe_medic_gouv[ligne['group']])
    ratio_cnamts = ligne['prix_par_dosage_test_cnamts'] / float(prix_moyen_par_groupe_cnamts[ligne['group']])
    if ratio_medic_gouv < 1:
        ratio_medic_gouv = float(1) / ratio_medic_gouv
    if ratio_cnamts < 1:
        ratio_cnamts = float(1) / ratio_cnamts
        
    if ratio_medic_gouv < ratio_cnamts:
        ligne['base_choisie'] = 'medic_gouv'
    else:
        ligne['base_choisie'] = 'cnamts'
    return ligne

def choix_du_dosage(ligne):
    if ligne['base_choisie'] == 'medic_gouv':
        ligne['dosage_par_prestation'] = ligne['dosage_par_prestation_medic_gouv']     
    else:
        ligne['dosage_par_prestation'] = ligne['dosage_par_prestation_cnamts']
    return ligne

try:
    base_bruto
except:
    base_bruto = load_all(from_gouv=info_utiles_from_gouv, maj_gouv=maj_gouv,
                      from_cnamts=info_utiles_from_cnamts)

    period = [int(x) for x in base_bruto.columns if isinstance(x, long)]
    #period_prix renvoie vers les colonnes qui décrivent le prix des medicaments
    period_prix = ['prix_' + str(x) for x in period]
    period_prix_par_dosage = ['prix_par_dosage_' + str(date) for date in period]
    period_dosage_rembourse = ['dosage_rembourse_' + str(date) for date in period]
    
    
    ##### On fait maintenant l'exploitation à partir de groupe :
    ### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
    ### Exemple : Id_groupe et is_princeps
    base_bruto['group'] = base_bruto['Id_Groupe']
    base_bruto['role'] = base_bruto['Type'] == 0 # a=b==0 --> a is true if b==0 // True pour le princeps
    
    #On conserve sulement les medicaments dont on connait le groupe generique
    base_bruto = base_bruto.loc[base_bruto['group'].notnull()]
    base_bruto['group'] = base_bruto['group'].astype(int)
    base_bruto['role'] = base_bruto['role'].astype(bool) #pour faire planter si on a trois groupes...
    
    # quelques infos pour faire joli
    nombre_cip = len(base_bruto['CIP13'].unique())
    taille_base_bruto = len(base_bruto)
    print "La base base_bruto provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_bruto) + \
        " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."
    
    #On ne conserve que les lignes pour lesquelles on connait le dosage
    base_bruto = base_bruto[base_bruto['Dosage'].notnull()]
    
    ### Date de chute du brevet, se généralise en "modification du groupe" ?
    ## On a deux méthodes concurrentes
    grp = base_bruto.groupby('group')
    
    #Calcul de la date de chute de brevet (2 methodes)
    chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
    chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
    #base_bruto['chute_brevet']=chute_brevet1
    
    # On enlève les lignes sans code ATC
    base_bruto = base_bruto[~base_bruto['CODE_ATC'].isnull()]    
    
    base_bruto['nb_ref_in_label_medic_gouv'] = mg.table_update(base_bruto)
    print 'len base_bruto is : ' + str(len(base_bruto))
    
    
    #Supprime les doublons dans base_bruto en séléctionnant en priorité la substance qui est déjà présente

base_brute = base_bruto     

#base_brute = base_brute = groupe_substance_unique(base_brute)

#on veut les groupes avec à la fois des génériques et des princeps
#(il y a au moins un princeps) & (il y a au moins un non princeps) & (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
cond = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0) & (chute_brevet1 > period[0])

period_str = [str(t) for t in period]

#base_brute = base_brute.loc[~base_brute['Dosage'].isnull(),:]
base_brute = calcul_prix_par_dosage_test(base_brute)
base_brute = choix_de_la_base(base_brute)
base_brute['dosage_par_prestation'] = None
base_brute = base_brute[base_brute['base_choisie'] != 'Aucune'] # On élimine les médicaments pour lesquels on n'a pas de dosage
print 'actuellement dans choix_du_dosage'
base_brute = base_brute.apply(lambda x: choix_du_dosage(x), axis = 1)


#ATTENTION : Modifie la base_brute
base_brute = base_brute.loc[~(base_brute['dosage_par_prestation'] == 0), :]

test = base_brute.apply(lambda x: x.loc[period]*x.loc['dosage_par_prestation'], axis=1) 
test.columns = period_dosage_rembourse
base_brute[period_dosage_rembourse] = test

#Calcul du prix par dosage pour chaque médicament
base_brute[period_prix_par_dosage] = base_brute.apply(lambda x: x[period_prix].divide(x['dosage_par_prestation']), axis=1)

preparation_base_period_prix(base_brute)


def cout_classe (code_atc):
    '''Calcul la différence de prix si tous les médicaments étaient remboursés au prix du moins cher dans la classe'''
    base_classe = base_brute.loc[base_brute['CODE_ATC']==code_atc,:]
    prix_min_par_dosage=base_classe[period_prix_par_dosage].apply(lambda column: min(column))
    # On considere que tous les médicaments d'ASMR V peuvent être remplacés par un médicament de la même classe (dosage équivalent) moins cher
    # On calcule donc la différence de cout pour tous les médicaments d'ASMR V
    cout = sum(base_classe.loc[base_classe['Valeur_ASMR']=='V',:].apply(lambda x: dot(x.loc[period_dosage_rembourse],(x[period_prix_par_dosage]-prix_min_par_dosage)),axis=1))
    return cout
    
def cout_groupe (id_groupe):
    '''Calcul la différence de prix si tous les médicaments étaient remboursés au prix du moins cher dans le groupe'''
    base_groupe= base_brute.loc[base_brute['Id_Groupe']==id_groupe,:]
    prix_min_par_dosage=base_groupe[period_prix_par_dosage].apply(lambda column: min(column))
    # On considere que tous les médicaments d'ASMR V peuvent être remplacés par un médicament de la même classe (dosage équivalent) moins cher
    # On calcule donc la différence de cout pour tous les médicaments d'ASMR V
    cout = sum(base_groupe.loc[base_groupe['Valeur_ASMR']=='V',:].apply(lambda x: dot(x.loc[period_dosage_rembourse],(x[period_prix_par_dosage]-prix_min_par_dosage)),axis=1))
    return cout

def dot(a,b):
    assert sum(b.isnull())==0
    x=a
    y=b
    x.index = y.index
    x_null = x.isnull()
    x=x[~x_null]
    y=y[~x_null]
    return sum(x*y)
           
'''Calcul du couts des médicaments d ASMR V plus chers'''
codes_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','CODE_ATC']))
group_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','Id_Groupe']))
#cout_total_class=sum([cout_classe(code_atc) for code_atc in codes_set])
#cout_total_groupe=sum([cout_groupe(id_groupe) for id_groupe in group_set])  
    
def ecart_max(id_groupe, date = 201406):
    '''Calcul de l'écart relatif maximal de prix au sein d'un groupe pour une date donnée'''
    string = 'prix_par_dosage_' + str(date)
    
    prix_par_dosage_groupe = base_brute.loc[base_brute['Id_Groupe']==id_groupe, string]
    #prix_par_dosage_groupe = prix_par_dosage_groupe[test]
    #print prix_par_dosage_groupe
    prix_par_dosage_groupe = prix_par_dosage_groupe[~prix_par_dosage_groupe.isnull()]
    try:
        ecart_relatif = max(prix_par_dosage_groupe) / min(prix_par_dosage_groupe)
    except:
        ecart_relatif = 0
    return(ecart_relatif)
        
a=[{'Id_Groupe' : x, 'ecart' : ecart_max(x)} for x in list(set(base_brute['Id_Groupe']))]
#b est le rapport du plus grand prix sur le plus peit pour chaque groupe.
rapport_max_prix = sorted(a, key=lambda x: x['ecart'])

'''Determiner pour chauque groupe la date du premier générique'''

def date_generique(table_groupe):
    if sum(table_groupe['Type'] == 1) == 0:
        return 201406
    else:
        return table_groupe.loc[table_groupe['Type'] == 1, 'premiere_vente'].min()

def atc_niv_4(table):
    
    table['CODE_ATC_4'] = table['CODE_ATC'].apply(lambda x: x[:5])
    return table
    

def is_me_to(table_classe):
    group_start = table_classe.groupby('Id_Groupe')['premiere_vente'].min()
    table_classe['premier_de_la_classe'] = table_classe['premiere_vente'].apply(lambda x: x == group_start.min())
    is_me_to = table_classe.apply(lambda x: x['Valeur_ASMR'] == 'V' and not x['premier_de_la_classe'] and x['Type'] == 0, axis=1)
    return is_me_to
    
def cout (dosage, prix_par_dosage):
    #print dosage
    assert len(dosage) == len (prix_par_dosage)
    dosage.index = period
    prix_par_dosage.index = period
    return (dosage*prix_par_dosage).sum()



date_generication_groupe = base_brute.groupby('Id_Groupe').apply(lambda x: date_generique(x))
base_brute = atc_niv_4(base_brute)

#graph(164)
#graph_ma(164)
#plt.show()
#
#gouv_not_in_sniiram = gouv[~gouv['CIP13'].isin(sniiram.index)]
#gouv_not_in_sniiram_remb = gouv_not_in_sniiram[~gouv_not_in_sniiram['Taux_rembours'].isnull()]
#gouv_not_in_sniiram['Taux_rembours'].isnull().sum()
#pd.value_counts(gouv_not_in_sniiram['Taux_rembours'])
#
#sniiram_not_in_gouv = sniiram[~sniiram.index.isin(gouv['CIP13'])]
#sniiram_in_gouv = sniiram[sniiram.index.isin(gouv['CIP13'])]
#cip_test = sniiram_not_in_gouv.index // 100000000
#pd.value_counts(cip_test)
#sniiram_not_in_gouv2 = sniiram_not_in_gouv[cip_test == 34009]
#cip_test2 = sniiram_not_in_gouv2.index // 1000000
#pd.value_counts(cip_test2)
#
#cip_gouv = gouv['CIP13'] // 100000000
#cip_test_gouv = pd.value_counts(cip_gouv)
#
#pd.value_counts(derniere_vente[sniiram_not_in_gouv.index])
#(derniere_vente[sniiram_not_in_gouv.index] < 201101).sum()
#(derniere_vente[sniiram_not_in_gouv2.index].isnull()).sum()
#
#group_with_generic = grp.apply(lambda x: x['role'].sum() > 0)
#
#nombre_generic[nombre_generic.index==195].sum(axis=1)
#nombre_princeps[nombre_princeps.index==195]
#plt.scatter(nombre_generic[nombre_generic.index==195],period)
#pd.DataFrame.hist(nombre_generic[nombre_generic.index==195],period)
#plt.hist(evolution_princeps)
#
#test = nombre_generic[(nombre_generic.index==195)|(nombre_generic.index==914)].transpose()
#
##period_homogene=(period//100)*100+(period%100)*100/12
#plot = plt.scatter(period_homogene,nombre_generic[nombre_generic.index==195])
#plt.show()
#
#period_dt = [(t//100,t%100) for t in period]
#
#str(period%100)
#str(period//100)
#dt.datetime.strptime(str(period//100),"%m/%Y").date()


