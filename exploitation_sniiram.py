# -*- coding:utf-8 -*-
'''
Created on 5 août 2014

@author: tvialette
'''

import numpy as np
import pandas as pd
from pandas import DataFrame
import pdb

from load_data.load import load_all

# Numéro de la mise à jour pour la base medicaments.gouv
maj_gouv = 'maj_20140915122241'
# parametres du calcul
# Ne marche pas si la liste inclut 'CIS'
info_utiles_from_gouv = ['CIP7', 'CIP13', 'Nom', 'Id_Groupe', 'Prix',
                         'Code_Substance', 'Nom_Substance', 'Libelle_ASMR', 'Type',
                         'Date_declar_commerc', 'Date_AMM', 'Taux_rembours',
                         'indic_droit_rembours', 'Statu_admin_presta',
                         'Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR']
info_utiles_from_cnamts = ['CIP', 'CODE_ATC'] #LABO

base_brute = load_all(from_gouv=info_utiles_from_gouv, maj_gouv=maj_gouv,
                      from_cnamts=info_utiles_from_cnamts)

period = [int(x) for x in base_brute.columns if isinstance(x, long)]
#period_prix renvoie vers les colonnes qui décrivent le prix des medicaments
period_prix = ['prix_' + str(x) for x in period]
period_prix_par_dosage = ['prix_par_dosage_' + str(date) for date in period]
period_dosage_rembourse = ['dosage_rembourse_' + str(date) for date in period]




##### On fait maintenant l'exploitation à partir de groupe :
### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
### Exemple : Id_groupe et is_princeps
base_brute['group'] = base_brute['Id_Groupe']
base_brute['role'] = base_brute['Type'] == 0 # a=b==0 --> a is true if b==0 // True pour le princeps

#On conserve sulement les medicaments dont on connait le groupe generique
base_brute = base_brute.loc[base_brute['group'].notnull()]
base_brute['group'] = base_brute['group'].astype(int)
base_brute['role'] = base_brute['role'].astype(bool) #pour faire planter si on a trois groupes...

# quelques infos pour faire joli
nombre_cip = len(base_brute['CIP13'].unique())
taille_base_brute = len(base_brute)
print "La base base_brute provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_brute) + \
    " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."

#On ne conserve que les lignes pour lesquelles on connait le dosage
base_brute = base_brute[base_brute['Dosage'].notnull()]

### Date de chute du brevet, se généralise en "modification du groupe" ?
## On a deux méthodes concurrentes
grp = base_brute.groupby('group')

#Calcul de la date de chute de brevet (2 methodes)
chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
#base_brute['chute_brevet']=chute_brevet1


#on veut les groupes avec à la fois des génériques et des princeps
#(il y a au moins un princeps) & (il y a au moins un non princeps) & (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
cond = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0) & (chute_brevet1 > period[0])

period_str = [str(t) for t in period]

def select(table):
    ''' Permet d'appliquer les conditions (ci dessus) à la table '''
    table2 = table.loc[cond.index[cond]]
    return table2

def print_role(data, Type=False):
    if Type:
        assert 'Type' in data.columns
        role = data['Type']
        assert any(role == 0)
        print('\n *** princeps ***' )
        print (data[role == 0])
        if any(role == 1):
            print('\n *** génériques ***' )
            print (data[role == 1])
        else:       
            print('\n pas de générique pour ce groupe' )
    else:
        print data
    

def info_display(name=None ,CIP13=None, Id_Groupe=None, CODE_ATC= None, variables=None, return_tab=False):
    '''Display des informations sur les medicaments,
        choisir les données à montrer dans "variables",
        return_tab=True si on veut renvoyer un objet, =False pour le print'''
    base_brute.sort(['Id_Groupe', 'Date_declar_commerc'])
    if variables==None:
        vars_display=['Id_Groupe','Type','LABO','Date_declar_commerc','prix_par_dosage']
    else :
        vars_display=variables
    if name != None:
        disp =base_brute.loc[base_brute['Nom'].str.contains(name, case=False, na=False),vars_display]
    if CIP13 != None:
        disp = base_brute.loc[base_brute['CIP13']==CIP13,vars_display]
    if CODE_ATC != None:
        disp = base_brute.loc[base_brute['CODE_ATC']==CODE_ATC,vars_display]
    if Id_Groupe != None:
        disp = base_brute.loc[base_brute['Id_Groupe']==Id_Groupe,vars_display]

    if return_tab:
        return disp
    else:
        Type = 'Type' in vars_display
        if 'Id_Groupe' in vars_display:
            for grp in list(set(disp['Id_Groupe'])):
                print_role(disp.loc[disp['Id_Groupe']==grp,:], Type)
                print '\n'
        else:
            print_role(disp, Type)
    #return disp

def moving_average(table, size):
    assert size % 2 == 0
    mid_size = size/2
    output = DataFrame(columns=table.columns, index=table.index)
    for date in range(mid_size, len(table.columns) - mid_size):
        output[output.columns[date]] = table.iloc[:,(date-mid_size+1):(date+mid_size+1)].mean(axis=1) #les dépenses du mois sont prise en fin de mois
#     for group in output.index:
#         output[table[table.index == group].isnull()] = None
    return output


def evolution(table):
    '''Calcul des differences de consommation'''
    evolution = pd.DataFrame(index = table.index, columns = period[1:])
    table[table==0] = None
    last_month = table[period[0]]
    for month in period[1:]:
        evolution[month] = (table[month] - last_month)/last_month
        last_month = table[month]
    return evolution


def graph(group):
    ''' Créer le plot de comparaison entref princeps et generic '''
    col0 = nombre_princeps[nombre_princeps.index == group].values
    col1 = nombre_generic[nombre_generic.index == group].values
    col2 = col0 + col1
    output = DataFrame({'princeps':col0, 'generic':col1, 'total':col2}, index = period_str).plot()
    return output

def graph_ma(group):
    ''' Créer le plot de comparaison entre princeps et generic '''
    col0 = moving_average_princeps[moving_average_princeps.index == group]
    col1 = moving_average_generic[moving_average_generic.index == group]
    col2 = col0.add(col1,fill_value=0)
    col0 = col0.values
    col1 = col1.values
    col2 = col2.values

    if len(col1)>0: # On vérifie que col1 n'est pas vide (i.e. qu'il y a des génériques)
        output = DataFrame({'ma_princeps':col0[0], 'ma_generic':col1[0], 'ma_total':col2[0]}, index = period_str)
    else:
        output = DataFrame({'ma_princeps':col0[0], 'ma_total':col2[0]}, index = period_str)
    #print output
    return output.plot()


def graph_ma_classe(CODE_ATC, proportion=False):  # code_substance):
    ''' Créer le plot de comparaison de consommation totale des groupes par classe'''
    output = None
    for group in list(set(base_brute.loc[base_brute['CODE_ATC']==CODE_ATC,'Id_Groupe'])):
        print group
        col0 = moving_average_princeps[moving_average_princeps.index == group]
        col1 = moving_average_generic[moving_average_generic.index == group]
        col2 = col0.add(col1,fill_value=0)
        #col2 = col2 / col2.T.mean(skipna=True).values[0]
        col2 = col2.values
        
        if output is None:
            print 'there'
            output=DataFrame(col2[0],index = period_str) #49632
        else :
            try:
                colu=pd.DataFrame(col2[0],index = period_str)
                output = output.join(colu, rsuffix='_'+str(group),how='outer')
            except:
                print 'exception'
    #print output
    if proportion == True:
        output = output.div(output.sum(axis=1), axis=0) #pour avoir la proportion de chaque groupe

    return output.plot()

def graph_prix_classe(CODE_ATC):
    '''Crée le plot du prix par substance pour tous les médicaments d'une même classe ATC'''
    output = base_brute.loc[base_brute.loc[:,'CODE_ATC']==CODE_ATC, period_prix_par_dosage]
    
    return output.transpose().plot()
        
    
#print(base_brute['Dosage'])

### On extrait la partie numérique du dosage pour ensuite multiplier par le nombre de doses individuelles par boite
base_brute['Dosage_num']=None
base_brute.loc[:,'Dosage_num']=base_brute['Dosage'].apply(lambda x: re.findall('\d*\.?\d+',str(x))[0])
#dosages = map(lambda x: re.findall('\d*\.?\d+',str(x)), base_brute['Dosage'])
dosages=base_brute['Dosage_num']


nb_ref_in_label = mg.table_update(base_brute)
base_brute['dosage_par_prestation']=[float(x)*float(y) for x,y in zip(dosages,nb_ref_in_label)]

#Quantité de prestations
nombre_princeps = base_brute[base_brute['role']].groupby('group')[period].sum()
nombre_generic = base_brute[~base_brute['role']].groupby('group')[period].sum()
nombre_total = base_brute.groupby('group')[period].sum()


#ATTENTION : Modifie la base_brute
base_brute = base_brute.loc[~(base_brute['dosage_par_prestation'] == 0), :]

#Calcul de la dose vendue par mois dans copy ####A VERIFIER
#copy=base_brute.loc[:,period]
#copy['dosage_par_prestation']=base_brute['dosage_par_prestation']
## Copy[period] contient le dosage mensuel remboursé
#copy[period]=copy.apply(lambda x: x[:len(x)-1]*x[len(x)-1],axis=1) 
test = base_brute.apply(lambda x: x.loc[period]*x.loc['dosage_par_prestation'], axis=1) 
test.columns = period_dosage_rembourse
base_brute[period_dosage_rembourse] = test

#Calcul du prix par dosage pour chaque médicament
base_brute[period_prix_par_dosage] = base_brute.apply(lambda x: x[period_prix].divide(x['dosage_par_prestation']), axis=1)

#On recopie base_brute dans copy
#copy[['role','group','CODE_ATC','Id_Groupe','Valeur_ASMR']]=base_brute[['role','group','CODE_ATC','Id_Groupe','Valeur_ASMR']]

#On copie le prix par dosage dans la base brute
#base_brute['prix_par_dosage']=None
#base_brute[period_prix_par_dosage]=copy[period_prix_par_dosage]

#Quantité de substance (en masse ou volume etc...) pour chaque groupe
nombre_dosage_princeps = base_brute[base_brute['role']].groupby('group')[period].sum()
nombre_dosage_generic = base_brute[~base_brute['role']].groupby('group')[period].sum()
nombre_dosage_total = base_brute.groupby('group')[period].sum()

#Quantité moyenne sur un an de substance (en masse ou volume etc...) pour chaque groupe
moving_average_princeps = moving_average(nombre_princeps, 12)
moving_average_generic = moving_average(nombre_generic, 12)
moving_average_total = moving_average(nombre_total, 12)

# Différence des quantités de substancee vendue
evolution_princeps = evolution(select(nombre_princeps))
evolution_generic = evolution(select(nombre_generic))
evolution_total = evolution(select(nombre_total))
#evolution_princeps.sum(axis=1).isnull().sum()


#Montre le nombre de groupes par code substance substance
def class_count():
    for code in set(base_brute['CODE_ATC']):
        b=set(base_brute.loc[base_brute['CODE_ATC']==code,'Id_Groupe'])
        print str(code) + ' --->> ' + str(len(b))
        print b



def cout_classe (code_atc):
    '''ATTENTION : Utilise copy : à changer'''
    base_classe = base_brute.loc[base_brute['CODE_ATC']==code_atc,:]
    prix_min_par_dosage=base_classe[period_prix_par_dosage].apply(lambda column: min(column))
    # On considere que tous les médicaments d'ASMR V peuvent être remplacés par un médicament de la même classe (dosage équivalent) moins cher
    # On calcule donc la différence de cout pour tous les médicaments d'ASMR V
    cout = sum(base_classe.loc[base_classe['Valeur_ASMR']=='V',:].apply(lambda x: dot(x.loc[period_dosage_rembourse],(x[period_prix_par_dosage]-prix_min_par_dosage)),axis=1))
    return cout
    
    
def dot(a,b):
    assert sum(b.isnull())==0
    x=a
    y=b
    x.index = y.index
    x_null = x.isnull()
    x=x[~x_null]
    y=y[~x_null]
    return sum(x*y)
        
'''Calcul du couts des nouveaux princeps d ASMR V '''

codes_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','CODE_ATC']))
cout_total=sum([cout_classe(code_atc) for code_atc in codes_set])
        
    
    
#graph(164)
#graph_ma(164)
#plt.show()
#
#
#gouv_not_in_sniiram = gouv[~gouv['CIP13'].isin(sniiram.index)]
#gouv_not_in_sniiram_remb = gouv_not_in_sniiram[~gouv_not_in_sniiram['Taux_rembours'].isnull()]
#gouv_not_in_sniiram['Taux_rembours'].isnull().sum()
#pd.value_counts(gouv_not_in_sniiram['Taux_rembours'])
#
#sniiram_not_in_gouv = sniiram[~sniiram.index.isin(gouv['CIP13'])]
#sniiram_in_gouv = sniiram[sniiram.index.isin(gouv['CIP13'])]
#cip_test = sniiram_not_in_gouv.index // 100000000
#pd.value_counts(cip_test)
#sniiram_not_in_gouv2 = sniiram_not_in_gouv[cip_test == 34009]
#cip_test2 = sniiram_not_in_gouv2.index // 1000000
#pd.value_counts(cip_test2)
#
#cip_gouv = gouv['CIP13'] // 100000000
#cip_test_gouv = pd.value_counts(cip_gouv)
#
#pd.value_counts(derniere_vente[sniiram_not_in_gouv.index])
#(derniere_vente[sniiram_not_in_gouv.index] < 201101).sum()
#(derniere_vente[sniiram_not_in_gouv2.index].isnull()).sum()
#
#
#group_with_generic = grp.apply(lambda x: x['role'].sum() > 0)
#
#nombre_generic[nombre_generic.index==195].sum(axis=1)
#nombre_princeps[nombre_princeps.index==195]
#plt.scatter(nombre_generic[nombre_generic.index==195],period)
#pd.DataFrame.hist(nombre_generic[nombre_generic.index==195],period)
#plt.hist(evolution_princeps)
#
#test = nombre_generic[(nombre_generic.index==195)|(nombre_generic.index==914)].transpose()
#
##period_homogene=(period//100)*100+(period%100)*100/12
#plot = plt.scatter(period_homogene,nombre_generic[nombre_generic.index==195])
#plt.show()
#
#period_dt = [(t//100,t%100) for t in period]
#
#str(period%100)
#str(period//100)
#dt.datetime.strptime(str(period//100),"%m/%Y").date()


