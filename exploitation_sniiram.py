# -*- coding:utf-8 -*-
'''
Created on 5 août 2014

@author: tvialette
'''

import numpy as np
import pandas as pd
from pandas import DataFrame
import pdb
import datetime as dt
import matplotlib.pyplot as plt
import scipy.stats as stats
import re

import medic_gouv_with_dosage_strategie2 as mg
import bdm_cnamts as cnamts

#from medicam import load_medicament
from sniiram import load_sniiram

# Numéro de la mise à jour pour la base medicaments.gouv
maj_bdm = 'maj_20140915122241\\'
# parametres du calcul
info_utiles_from_gouv = ['CIP7','CIP13','Nom','Id_Groupe','Code_Substance','Libelle_ASMR','Type', 'Date_declar_commerc', 'Date_AMM', 'Taux_rembours','Prix', 'indic_droit_rembours', 'Statu_admin_presta','Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR']
info_utiles_from_cnamts = ['CIP', 'CIP7', 'LABO', 'CODE_ATC']

#def load_base_brute(info_utiles_from_gouv, info_utiles_from_cnamts):

#Chargement des données médicaments.gouv et cnamts
gouv = mg.load_medic_gouv(maj_bdm, var_to_keep=info_utiles_from_gouv, CIP_not_null=True)
cnamts = cnamts.bdm_cnamts(info_utiles_from_cnamts)

# Chargement de la base Sniiram
sniiram = load_sniiram()
period = sniiram.columns
assert all(period == sorted(period))

# On met les dates au format datetime
for var in info_utiles_from_gouv:
    if 'date' in var or 'Date' in var:
        
        gouv = gouv[pd.notnull(gouv[var])]
        
        gouv[var]  = gouv[var].map(lambda t : dt.datetime.strptime(t,"%d/%m/%Y").date())
        for time_idx in ['month','year']:
            name = var + '_' + time_idx
            gouv[name] = 0
            gouv[name][gouv[var].notnull()] = gouv[var][gouv[var].notnull()].apply(lambda x: getattr(x, time_idx))
        
# Pour chaque médicament on détermine l'année de la première vente :

# Determiner les dates de premieres ventes
premiere_vente = pd.Series(index=sniiram.index)
derniere_vente = pd.Series(index=sniiram.index)
for month in period:
    vente = sniiram[month] > 0
    cond_prem = vente & premiere_vente.isnull()
    premiere_vente[cond_prem] = month
    cond_dern = ~vente & premiere_vente.notnull() & derniere_vente.isnull()
    derniere_vente[cond_dern] = month - 1

# Ajout de la donnée première vente à la base Sniiram
sniiram['premiere_vente'] = premiere_vente
sniiram['derniere_vente'] = derniere_vente

# On merge les bases Sniiram et cnamts
base_brute = pd.merge(gouv, cnamts, left_on = 'CIP13', right_on='CIP')
base_brute = pd.merge(base_brute, sniiram, left_on='CIP13', right_index=True)
    
#test?
#    var = 'Date_declar_commerc'
#    test = 100*base_brute[var+'_year'] + base_brute[var+'_month'] - base_brute['premiere_vente']
#    test_in_month = abs(test)
#    test_in_month.value_counts()

##### On fait maintenant l'exploitation à partir de groupe : 
### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
### Exemple : Id_groupe et is_princeps
base_brute['group'] = base_brute['Id_Groupe']
base_brute['role'] = base_brute['Type'] == 0 # a=b==0 --> a is true if b==0 // True pour le princeps

#On conserve sulement les medicaments dont on connait le groupe generique
base_brute = base_brute.loc[base_brute['group'].notnull()]
base_brute['group'] = base_brute['group'].astype(int)
base_brute['role'] = base_brute['role'].astype(bool) #pour faire planter si on a trois groupes...

# quelques infos pour faire joli
nombre_cip = len(base_brute['CIP13'].unique())
taille_base_brute = len(base_brute)
print "La base base_brute provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_brute) + \
    " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."

#On ne conserve que les lignes pour lesquelles on connait le dosage 
base_brute=base_brute[~base_brute['Dosage'].isnull()]

### Date de chute du brevet, se généralise en "modification du groupe" ? 
## On a deux méthodes concurrentes
grp = base_brute.groupby('group')

#Calcul de la date de chute de brevet (2 methodes)
chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
base_brute['chute_brevet']=chute_brevet1


#on veut les groupes avec à la fois des génériques et des princeps
#(il y a au moins un princeps) & (il y a au moins un non princeps) & (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
cond = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0) & (chute_brevet1 > period[0]) 

period_str = [str(t) for t in period]
    
def select(table):
    ''' Permet d'appliquer les conditions (ci dessus) à la table '''
    table2 = table.loc[cond.index[cond]]
    return table2

def info_display(name=None ,CIP13=None, Id_Groupe=None, CODE_ATC= None, variables=None, return_tab=False):
    '''Display des informations sur les medicaments, 
        choisir les données à montrer dans "variables",
        return_tab=True si on veut renvoyer un objet, =False pour le print'''
    base_brute.sort(['Id_Groupe', 'Date_declar_commerc'])
    if variables==None:
        vars_display=['Id_Groupe','Type','LABO','Date_declar_commerc','prix_par_dosage']
    else : 
        vars_display=variables
    if name != None:
        disp =base_brute.loc[base_brute['Nom'].str.contains(name, case=False, na=False),vars_display]    
    if CIP13 != None:
        disp = base_brute.loc[base_brute['CIP13']==CIP13,vars_display]
    if CODE_ATC != None:
        disp = base_brute.loc[base_brute['CODE_ATC']==CODE_ATC,vars_display]
    if Id_Groupe != None:
        disp = base_brute.loc[base_brute['Id_Groupe']==Id_Groupe,vars_display].sort('Date_declar_commerc')
    
    if return_tab==True:
        return disp
    else:
        if 'Id_Groupe' in vars_display:
            for grp in list(set(disp['Id_Groupe'])):
                print disp.loc[disp['Id_Groupe']==grp,:]
                print '\n'    
        else:
            print disp
    #return disp
    
def moving_average(table, size):
    assert size % 2 == 0
    mid_size = size/2
    output = DataFrame(columns=table.columns, index=table.index)
    for date in range(mid_size, len(table.columns) - mid_size):
        output[output.columns[date]] = table.iloc[:,(date-mid_size+1):(date+mid_size+1)].mean(axis=1) #les dépenses du mois sont prise en fin de mois
#     for group in output.index:
#         output[table[table.index == group].isnull()] = None
    return output
    

def evolution(table):
    '''Calcul des differences de consommation'''
    evolution = pd.DataFrame(index = table.index, columns = period[1:])
    table[table==0] = None
    last_month = table[period[0]]
    for month in period[1:]:
        evolution[month] = (table[month] - last_month)/last_month
        last_month = table[month]
    return evolution


def graph(group):
    ''' Créer le plot de comparaison entref princeps et generic '''
    col0 = nombre_princeps[nombre_princeps.index == group].values
    col1 = nombre_generic[nombre_generic.index == group].values
    col2 = col0 + col1
    output = DataFrame({'princeps':col0, 'generic':col1, 'total':col2}, index = period_str).plot() 
    return output

def graph_ma(group):
    ''' Créer le plot de comparaison entre princeps et generic '''
    col0 = moving_average_princeps[moving_average_princeps.index == group]
    col1 = moving_average_generic[moving_average_generic.index == group]
    col2 = col0.add(col1,fill_value=0)
    col0 = col0.values
    col1 = col1.values
    col2 = col2.values
    
    if len(col1)>0: # On vérifie que col1 n'est pas vide (i.e. qu'il y a des génériques)
        output = DataFrame({'ma_princeps':col0[0], 'ma_generic':col1[0], 'ma_total':col2[0]}, index = period_str)
    else:
        output = DataFrame({'ma_princeps':col0[0], 'ma_total':col2[0]}, index = period_str)
    #print output    
    return output.plot() 
    
def graph_ma_classe(CODE_ATC, proportion=False):#code_substance):
    ''' Créer le plot de comparaison de consommation totale des groupes par classe'''
    output=None
    for group in list(set(base_brute.loc[base_brute['CODE_ATC']==CODE_ATC,'Id_Groupe'])):  
         print group        
         col0 = moving_average_princeps[moving_average_princeps.index == group]
         col1 = moving_average_generic[moving_average_generic.index == group]
         col2 = col0.add(col1,fill_value=0) 
         #col2 = col2 / col2.T.mean(skipna=True).values[0]
         col2 = col2.values
         
         if output is None:
             print 'there'
             output=DataFrame(col2[0],index = period_str) #49632
         else :
             try:
                 colu=pd.DataFrame(col2[0],index = period_str)
                 output = output.join(colu, rsuffix='_'+str(group),how='outer')
             except:
                 print 'exception'
    #print output 
    if proportion == True:
        output = output.div(output.sum(axis=1), axis=0) #pour avoir la proportion de chaque groupe        
    
    return output.plot()


    
#print(base_brute['Dosage'])
    
### On extrait la partie numérique du dosage pour ensuite multiplier par le nombre de doses individuelles par boite
base_brute['Dosage_num']=None
base_brute.loc[:,'Dosage_num']=base_brute['Dosage'].apply(lambda x: re.findall('\d*\.?\d+',str(x))[0])
#dosages = map(lambda x: re.findall('\d*\.?\d+',str(x)), base_brute['Dosage'])
dosages=base_brute['Dosage_num']



nb_ref_in_label = mg.table_update(base_brute)
base_brute['dosage_par_prestation']=[float(x)*y for x,y in zip(dosages,nb_ref_in_label)]

#Quantité de prestations
nombre_princeps = base_brute[base_brute['role']].groupby('group')[period].sum()
nombre_generic = base_brute[~base_brute['role']].groupby('group')[period].sum()
nombre_total = base_brute.groupby('group')[period].sum()


#ATTENTION : Modifie la base_brute
#base_brute[~base_brute['dosage_par_prestation'].isnan()]

#Calcul du dosage par prestation dans copy
copy=base_brute.loc[:,period]
copy['dosage_par_prestation']=base_brute['dosage_par_prestation']
copy['dosage_par_prestation']=copy.apply(lambda x: x[:len(x)-1]*x[len(x)-1],axis=1)

#Calcul du prix par dosage pour chaque médicament
copy['prix_par_dosage']=base_brute['Prix'].divide(base_brute['dosage_par_prestation'])

#On recopie base_brute dans copy
copy[['role','group','CODE_ATC','Id_Groupe']]=base_brute[['role','group','CODE_ATC','Id_Groupe']]

#On copie le prix par dosage dans la base brute
base_brute['prix_par_dosage']=None
base_brute['prix_par_dosage']=copy['prix_par_dosage']
       
#Quantité de substance (en masse ou volume etc...) pour chaque groupe
nombre_dosage_princeps = copy[copy['role']].groupby('group')[period].sum()
nombre_dosage_generic = copy[~copy['role']].groupby('group')[period].sum()
nombre_dosage_total = copy.groupby('group')[period].sum()

#Quantité moyenne sur un an de substance (en masse ou volume etc...) pour chaque groupe
moving_average_princeps = moving_average(nombre_princeps, 12)
moving_average_generic = moving_average(nombre_generic, 12)
moving_average_total = moving_average(nombre_total, 12)

# Différence des quantités de substancee vendue
evolution_princeps = evolution(select(nombre_princeps))
evolution_generic = evolution(select(nombre_generic))
evolution_total = evolution(select(nombre_total))
#evolution_princeps.sum(axis=1).isnull().sum()


#Montre le nombre de groupes par code substance substance
def class_count():
    for code in set(base_brute['CODE_ATC']):
        b=set(base_brute.loc[base_brute['CODE_ATC']==code,'Id_Groupe'])
        print str(code) + ' --->> ' + str(len(b)) 
        print b
        

#graph(164)
#graph_ma(164)
#plt.show()
#
#
#gouv_not_in_sniiram = gouv[~gouv['CIP13'].isin(sniiram.index)]
#gouv_not_in_sniiram_remb = gouv_not_in_sniiram[~gouv_not_in_sniiram['Taux_rembours'].isnull()]
#gouv_not_in_sniiram['Taux_rembours'].isnull().sum()
#pd.value_counts(gouv_not_in_sniiram['Taux_rembours'])
#
#sniiram_not_in_gouv = sniiram[~sniiram.index.isin(gouv['CIP13'])]
#sniiram_in_gouv = sniiram[sniiram.index.isin(gouv['CIP13'])]
#cip_test = sniiram_not_in_gouv.index // 100000000 
#pd.value_counts(cip_test)
#sniiram_not_in_gouv2 = sniiram_not_in_gouv[cip_test == 34009]
#cip_test2 = sniiram_not_in_gouv2.index // 1000000
#pd.value_counts(cip_test2)
#
#cip_gouv = gouv['CIP13'] // 100000000 
#cip_test_gouv = pd.value_counts(cip_gouv)
#
#pd.value_counts(derniere_vente[sniiram_not_in_gouv.index])
#(derniere_vente[sniiram_not_in_gouv.index] < 201101).sum()
#(derniere_vente[sniiram_not_in_gouv2.index].isnull()).sum()
#
#
#group_with_generic = grp.apply(lambda x: x['role'].sum() > 0)
#
#nombre_generic[nombre_generic.index==195].sum(axis=1)
#nombre_princeps[nombre_princeps.index==195]
#plt.scatter(nombre_generic[nombre_generic.index==195],period)
#pd.DataFrame.hist(nombre_generic[nombre_generic.index==195],period)
#plt.hist(evolution_princeps)
#
#test = nombre_generic[(nombre_generic.index==195)|(nombre_generic.index==914)].transpose()
#
##period_homogene=(period//100)*100+(period%100)*100/12
#plot = plt.scatter(period_homogene,nombre_generic[nombre_generic.index==195])
#plt.show()
#
#period_dt = [(t//100,t%100) for t in period]
#
#str(period%100)
#str(period//100)
#dt.datetime.strptime(str(period//100),"%m/%Y").date()


