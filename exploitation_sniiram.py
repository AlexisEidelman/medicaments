# -*- coding:utf-8 -*-
'''
Created on 5 août 2014

@author: tvialette, aeidelman, lbouloc
'''

import numpy as np
import pandas as pd
from pandas import DataFrame



import display_and_graphs as dg
from datasets_ddd import dataset_ddd
from display_and_graphs import info_display


# Numéro de la mise à jour pour la base medicaments.gouv
maj_gouv = 'maj_20140915122241'
# parametres du calcul
# Ne marche pas si la liste inclut 'CIS'
info_utiles_from_gouv = ['CIP7', 'CIP13', 'Nom', 'Id_Groupe', 'Prix', 'Titulaires', 'Num_Europe',
                         'Code_Substance', 'Nom_Substance', 'Libelle_ASMR', 'Type',
                         'Date_declar_commerc', 'Date_AMM', 'Taux_rembours',
                         'indic_droit_rembours', 'Statu_admin_presta',
                         'Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR',
                         'nb_ref_in_label_medic_gouv', 'premiere_vente', 'derniere_vente']
info_utiles_from_cnamts = ['CIP', 'CODE_ATC', 'LABO', 'DOSAGE_SA',
                           'UNITE_SA', 'NB_UNITES'] #LABO

info_utiles_from_atc_ddd = ['CODE_ATC', 'CHEMICAL_SUBSTANCE', 'DDD', 'UNITE', 'MODE']


def cip_unique(table):
    table['cip_unique'] = pd.Series([False]*len(table), index = table.index)
    code_substance_present = []
    i = 0
    for cip in set(table['CIP']):
        i += 1
        if i % 100 == 0:
            print i
        test = table['CIP'] == cip
        # S'il y a plus d'un médicament de même CIP dans la base
        if sum(test) != 1:
            trouve = False
            # Pour toutes les médicaments de même CIP
            for index in table[test].index:
                code = table.loc[index, 'Code_Substance']
                # On cherche d'abord s'il y en a un dont la substance est déjà parmi les médicaments séléctionnés
                if code in code_substance_present:
                    table.loc[index, 'cip_unique'] = True
                    trouve = True
                    break
            # Si on n'en trouve pas, on rajoute le premier de la liste aux médicaments séléctionnés
            if not trouve:
                table.loc[index, 'cip_unique'] = True
        else:
            table.loc[table['CIP'] == cip, 'cip_unique'] = True
    return table


def groupe_substance_unique(table):
    group_select = table.groupby('Id_Groupe').apply(lambda x: len(set(x['Code_Substance'])) == 1)
    group_select_set = list(set(group_select.index[group_select]))
    table = table[table['Id_Groupe'].isin(group_select_set)]
    return table


def calcul_prix_par_dj_par_presta(table):
    '''Calcul du prix_par_dj_par_presta'''
    for date in period:
        string_prix = 'prix_' + str(date)
        string_prix_par_dj = 'prix_par_dj_' + str(date)
        table[string_prix_par_dj] = table[string_prix] / table['dj_par_presta']
    return table


def get_index(date):
    '''prend comme entrée une date au format YYYYMM et renvoie
    l'index numérique de cette date dans périod'''
    output = (int(date)/100 - 2003)*12 + int(date) % 100 - 1
    return output


def rewrite_period_prix(ligne):
    '''sert dans la fonciont preparation_base_period_prix'''
    index = get_index(ligne['premiere_vente'])
    for i in range(index):
        ligne[period_prix_par_dosage[i]] = np.nan
        ligne[period_prix[i]] = np.nan
    return ligne

# Modifient les prix pour une meilleure visualisation sur les graphs'''
def preparation_base_period_prix(table):
    '''Remplace par des nan les valeurs prix avant que le médicament soit vendu (pour qu'il n'apparaisse pas dans les graphs)'''
    print 'actuellement dans preparation_base_period_prix'
    table['premiere_vente'] = table['premiere_vente'].fillna(200301)
    table = table.apply(rewrite_period_prix, axis=1)
    return table

'''Determiner pour chaque groupe la date du premier générique'''


def date_generique(table_groupe):
    if sum(table_groupe['Type'] == 1) == 0:
        return 201406
    else:
        value = table_groupe.loc[table_groupe['Type'] == 1, 'premiere_vente'].min()
        if np.isnan(value):
            return 201406
        else:
            return value


def cout(dosage, prix_par_dosage):
    # print dosage
    assert len(dosage) == len(prix_par_dosage)
    dosage.index = period
    prix_par_dosage.index = period
    return (dosage*prix_par_dosage).sum()


def filtrage_par_ratio_prix(table, max_ratio=7):
    '''On élimine les groupes pour lequel l'écart de prix par dose est supérieur au seuil : max_ratio'''
    date = 201406
    price = 'prix_par_dosage_' + str(date)
    table = table.groupby(['Id_Groupe']).filter(lambda x: x[price].max() < max_ratio*x[price].min())
    return table


def filtrage_par_dj_par_presta(table):
    '''On réduit la base aux médicaments dont le nombre de doses journalières par prestation est compris entre 1 et 360'''
    print 'actuellement dans filtrage_par_dj_par_presta'
    table = table[table['dj_par_presta'].notnull()]
    table = table[table['dj_par_presta'] >= 1]
    table = table[table['dj_par_presta'] <= 360]
    '''On ne garde qu'une ligne par médicament'''
    table = table.drop_duplicates(subset = 'CIP7')
    print 'On a désormais : ' + str(len(table)) + ' medicaments uniques'
    return table


'''Load de la base brute et définition de variables essentielles'''
base_brute = dataset_ddd(info_utiles_from_atc_ddd, info_utiles_from_gouv, maj_gouv, info_utiles_from_cnamts, force=False)

period = [x for x in base_brute.columns if isinstance(x, long) or x[:2] in ['19', '20']]
# period_prix renvoie vers les colonnes qui décrivent le prix des medicaments
period_prix = [x for x in base_brute if x[:5] == 'prix_']
assert len(period_prix) == len(period)
period_prix_par_dosage = ['prix_par_dosage_' + str(date) for date in period]
period_nb_dj_rembourse = ['nb_dj_rembourse_' + str(date) for date in period]
period_prix_par_dj = ['prix_par_dj_' + str(date) for date in period]




##### On fait maintenant l'exploitation à partir de groupe :
### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
### Exemple : Id_groupe et is_princeps
base_brute['group'] = base_brute['Id_Groupe']
base_brute['role'] = base_brute['Type'] == 0 # a=b==0 --> a is true if b==0 // True pour le princeps

'''Filtrage de base_brute'''
#On conserve sulement les medicaments dont on connait le groupe generique
base_brute = base_brute.loc[base_brute['group'].notnull(), :]
#On ne conserve que les lignes pour lesquelles on connait le dosage
base_brute = base_brute[base_brute['Dosage'].notnull()]
# On enlève les lignes sans code ATC
base_brute = base_brute[base_brute['CODE_ATC'].notnull()]

base_brute.loc[:, 'group'] = base_brute.loc[:, 'group'].astype(int)
base_brute.loc[:, 'role'] = base_brute.loc[:, 'role'].astype(bool) #pour faire planter si on a trois groupes...

# quelques infos pour faire joli
nombre_cip = len(base_brute['CIP'].unique())
taille_base_brute = len(base_brute)
print "La base base_brute provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_brute) + \
    " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."

### Date de chute du brevet, se généralise en "modification du groupe" ?
## On a deux méthodes concurrentes
grp = base_brute.groupby('group')

# Calcul de la date de chute de brevet (2 methodes)
chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
# base_brute['chute_brevet']=chute_brevet1
print 'len base_brute is : ' + str(len(base_brute))

# Supprime les doublons dans base_brute en séléctionnant en priorité la substance qui est déjà présente
medicaments_par_classe_avt = base_brute.groupby('CODE_ATC_4')['CIP7'].nunique()
boites_vendues_par_classe_avt = base_brute.groupby('CODE_ATC_4')[period].sum().sum(axis=1)

#base_brute = base_brute = groupe_substance_unique(base_brute)

#on veut les groupes avec à la fois des génériques et des princeps
# (il y a au moins un princeps) & (il y a au moins un non princeps) & 
# (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
cond = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0) & (chute_brevet1 > int(period[0]))

'''Calcul du prix par dosage : necessaire pour la suite, pour le filtrage'''
base_brute = choix_de_la_base(base_brute)
base_brute['dosage_par_prestation'] = np.nan
base_brute = base_brute[base_brute['base_choisie'] != 'Aucune'] # On élimine les médicaments pour lesquels on n'a pas de dosage

print 'Effectue le choix du dosage'
base_brute['dosage_par_prestation'] = base_brute['dosage_par_prestation_cnamts']
base_medic = base_brute['base_choisie'] == 'medic_gouv'
base_brute.loc[base_medic, 'dosage_par_prestation'] = base_brute.loc[base_medic, 'dosage_par_prestation_medic_gouv']


#ATTENTION : Modifie la base_brute
base_brute = base_brute.loc[(base_brute['dosage_par_prestation'] != 0)]

#Calcul du prix par dosage pour chaque médicament
base_brute[period_prix_par_dosage] = base_brute.apply(lambda x: x[period_prix].divide(x['dosage_par_prestation']), axis=1)

'''Calcul du couts des médicaments d ASMR V plus chers'''
codes_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','CODE_ATC']))
group_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','Id_Groupe']))
#cout_total_class=sum([cout_classe(code_atc) for code_atc in codes_set])
#cout_total_groupe=sum([cout_groupe(id_groupe) for id_groupe in group_set])

###############################################
####### Début des dj

base_brute = filtrage_par_ratio_prix(base_brute)
base_brute = filtrage_par_dj_par_presta(base_brute)

# Calcul du nombre de dj remboursées
test = base_brute.apply(lambda x: x.loc[period]*x.loc['dj_par_presta'], axis=1)
test.columns = period_nb_dj_rembourse
base_brute[period_nb_dj_rembourse] = test

# Calcul du prix par dj_par_presta
base_brute = calcul_prix_par_dj_par_presta(base_brute)

####### Fin des dj
#################################################



###############################################
####### Début : filtrage pour les classes assez complètes
medicaments_par_classe_apr = base_brute.groupby('CODE_ATC_4')['CIP7'].nunique()
boites_vendues_par_classe_apr = base_brute.groupby('CODE_ATC_4')[period].sum().sum(axis = 1)

classes_a_conserver_nb = (medicaments_par_classe_apr/medicaments_par_classe_avt)
classes_a_conserver_nb = classes_a_conserver_nb > 0.7

classes_a_conserver_ventes = (boites_vendues_par_classe_apr/boites_vendues_par_classe_avt)
classes_a_conserver_ventes = classes_a_conserver_ventes > 0.7

classes_a_conserver = classes_a_conserver_nb & classes_a_conserver_ventes
classes_a_conserver = [i for i in classes_a_conserver.index if classes_a_conserver[i]]
base_brute = base_brute[base_brute['CODE_ATC_4'].isin(classes_a_conserver)]

print 'apres elimination des classes trop incomplètes, on a : ' + str(len(base_brute)) + ' lignes'
####### Fin : filtrage pour les classes assez complètes
#################################################


'''Ecart de prix par dosage par groupe/classe'''
date = 201406
maxim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].max()
minim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].min()
a = maxim/minim

'''Ecart de dj par presta par groupe/classe'''
maxim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].max()
minim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].min()
a = maxim/minim

rapport_max_prix = a.sort()

date_generication_groupe = base_brute.groupby('Id_Groupe').apply(date_generique)


#import display_and_graphs as dis
#dis.graph_prix_classe('C10AA')
