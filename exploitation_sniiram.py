# -*- coding:utf-8 -*-
'''
Created on 5 août 2014

@author: tvialette, aeidelman, lbouloc
'''

import numpy as np
import pandas as pd
from pandas import DataFrame

from datasets_ddd import dataset_ddd
from outils import all_periods

# Numéro de la mise à jour pour la base medicaments.gouv
maj_gouv = 'maj_20140915122241'
# parametres du calcul
# Ne marche pas si la liste inclut 'CIS'
info_utiles_from_gouv = ['CIP7', 'CIP', 'Nom', 'Id_Groupe', 'Prix', 'Titulaires', 'Num_Europe',
                         'Code_Substance', 'Nom_Substance', 'Nature_Composant', 'Libelle_ASMR', 'Type',
                         'Date_declar_commerc', 'Date_AMM', 'Taux_rembours',
                         'indic_droit_rembours', 'Statu_admin_presta',
                         'Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR', 'Date_ASMR',
                         'nb_ref_in_label_medic_gouv', 'premiere_vente', 'derniere_vente']
info_utiles_from_cnamts = ['CIP', 'CODE_ATC', 'LABO', 'DOSAGE_SA',
                           'UNITE_SA', 'NB_UNITES'] #LABO

info_utiles_from_atc_ddd = ['CODE_ATC', 'CHEMICAL_SUBSTANCE', 'DDD', 'UNITE', 'MODE']

def cip_unique(table):
    table['cip_unique'] = pd.Series([False]*len(table), index = table.index)
    code_substance_present = []
    i = 0
    for cip in set(table['CIP']):
        i += 1
        if i % 100 == 0:
            print i
        test = table['CIP'] == cip
        # S'il y a plus d'un médicament de même CIP dans la base
        if sum(test) != 1:
            trouve = False
            # Pour toutes les médicaments de même CIP
            for index in table[test].index:
                code = table.loc[index, 'Code_Substance']
                # On cherche d'abord s'il y en a un dont la substance est déjà parmi les médicaments séléctionnés
                if code in code_substance_present:
                    table.loc[index, 'cip_unique'] = True
                    trouve = True
                    break
            # Si on n'en trouve pas, on rajoute le premier de la liste aux médicaments séléctionnés
            if not trouve:
                table.loc[index, 'cip_unique'] = True
        else:
            table.loc[table['CIP'] == cip, 'cip_unique'] = True
    return table


def groupe_substance_unique(table):
    group_select = table.groupby('Id_Groupe').apply(lambda x: len(set(x['Code_Substance'])) == 1)
    group_select_set = list(set(group_select.index[group_select]))
    table = table[table['Id_Groupe'].isin(group_select_set)]
    return table


def rewrite_period_prix(ligne):
    '''sert dans la fonciont preparation_base_period_prix'''
    index = get_index(ligne['premiere_vente'])
    for i in range(index):
        ligne[period_prix_par_dosage[i]] = np.nan
        ligne[period_prix[i]] = np.nan
    return ligne

# Modifient les prix pour une meilleure visualisation sur les graphs'''
def preparation_base_period_prix(table):
    '''Remplace par des nan les valeurs prix avant que le médicament soit vendu (pour qu'il n'apparaisse pas dans les graphs)'''
    print 'actuellement dans preparation_base_period_prix'
    table['premiere_vente'] = table['premiere_vente'].fillna(200301)
    table = table.apply(rewrite_period_prix, axis=1)
    return table


def cout(table, period):
    '''Renvoie la table qui multiplie volume par dosage'''
    # print dosage
    assert len(period) == len(period_prix)
    dosage = table[period]
    prix = table[period_prix]    
    dosage.columns = period
    prix.columns = period
    return (dosage*prix)


def filtrage_par_ratio_prix(table, max_ratio=7):
    '''On élimine les groupes pour lequel l'écart de prix par dose est supérieur au seuil : max_ratio'''
    date = 201406
    price = 'prix_par_dosage_' + str(date)
    table = table.groupby(['Id_Groupe']).filter(lambda x: x[price].max() < max_ratio*x[price].min())
    return table


def filtrage_par_dj_par_presta(table):
    '''On réduit la base aux médicaments dont le nombre de doses journalières par prestation est compris entre 1 et 360'''
    print 'actuellement dans filtrage_par_dj_par_presta'
    table = table[table['dj_par_presta'].notnull()]
    table = table[table['dj_par_presta'] >= 1]
    table = table[table['dj_par_presta'] <= 360]
    '''On ne garde qu'une ligne par médicament'''
    table = table.drop_duplicates(subset = 'CIP') # previously CIP7
    print 'On a désormais : ' + str(len(table)) + ' medicaments uniques'
    return table


def filtrage_par_groupe_princeps_et_generique(table):
    '''on veut les groupes avec à la fois des génériques et des princeps'''
    grp = base_brute.groupby('Id_Groupe')
    # (il y a au moins un princeps) & (il y a au moins un non princeps) &
    # (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
    cond = (1 in grp['role']) & (0 in grp['role']) & (chute_brevet1 > int(period[0]))


#################################################################################>
######################## - - - DEBUT DU SCIRPT CI DESSOUS - - - #################>
#################################################################################>

def get_base_brute(force=False):
    '''Load de la base brute et définition de variables essentielles'''
    base_brute = dataset_ddd(info_utiles_from_atc_ddd, info_utiles_from_gouv, maj_gouv, info_utiles_from_cnamts, force=force)

    
    # très ad-hoc !!!
    for date in ['prix_201407', 'prix_201408', 'prix_201409']:
        base_brute[date] = base_brute['prix_201406']
    
    period, period_prix, period_prix_par_dosage, period_nb_dj_rembourse, period_prix_par_dj = all_periods(base_brute)

    # Compte le nombre de médicaments dans chaque classe et le nombre de boites vendues par classe avant tout filtrage

    '''Filtrage de base_brute'''
    #print "Elimination des lignes sans : 'Id_Groupe', 'Dosage', 'CODE_ATC' "
    ##On conserve sulement les medicaments dont on connait le groupe generique
    #base_brute = base_brute.loc[base_brute['Id_Groupe'].notnull(), :]
    ###On ne conserve que les lignes pour lesquelles on connait le dosage
    #base_brute = base_brute[base_brute['Dosage'].notnull()]
    ### On enlève les lignes sans code ATC
    #base_brute = base_brute[base_brute['CODE_ATC'].notnull()]


    ## Quelques infos pour faire joli
    #nombre_cip = len(base_brute['CIP'].unique())
    #taille_base_brute = len(base_brute)
    #print "La base base_brute provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_brute) + \
    #    " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."
    #del nombre_cip, taille_base_brute

    ### Date de chute du brevet, se généralise en "modification du groupe" ?
    ## On a deux méthodes concurrentes

    grp = base_brute.groupby('Id_Groupe')
    # Calcul de la date de chute de brevet (2 methodes)
    chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
#    chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
    chute_brevet = chute_brevet1.reset_index()
    chute_brevet.columns = ['Id_Groupe', 'chute_brevet']

    base_brute = base_brute = base_brute.merge(chute_brevet, how = 'outer')
    print 'len base_brute is : ' + str(len(base_brute))

    ## Supprime les doublons dans base_brute en séléctionnant en priorité la substance qui est déjà présente
    #base_brute = base_brute = groupe_substance_unique(base_brute)

    '''Calcul du prix par dosage : necessaire pour la suite, pour le filtrage'''
    base_brute['dosage_par_prestation'] = np.nan

    base_brute = base_brute[base_brute['base_choisie'] != 'Aucune'] # On élimine les médicaments pour lesquels on n'a pas de dosage

    print 'Effectue le choix du dosage'
    base_brute['dosage_par_prestation'] = base_brute['dosage_par_prestation_cnamts']
    base_medic = base_brute['base_choisie'] == 'medic_gouv'
    base_brute.loc[base_medic, 'dosage_par_prestation'] = base_brute.loc[base_medic, 'dosage_par_prestation_medic_gouv']


    #ATTENTION : Modifie la base_brute
    selector = base_brute['dosage_par_prestation'] != 0

    #Calcul du prix par dosage pour chaque médicament
    for x in period_prix_par_dosage:
        base_brute[x] = np.nan
    temp = base_brute.loc[selector, period_prix].divide(base_brute.loc[selector, 'dosage_par_prestation'], axis=0)
    temp.columns = period_prix_par_dosage
    base_brute.loc[selector, period_prix_par_dosage] = temp

    '''Calcul du couts des médicaments d ASMR V plus chers'''
    codes_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','CODE_ATC']))
    group_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','Id_Groupe']))
    #cout_total_class=sum([cout_classe(code_atc) for code_atc in codes_set])
    #cout_total_groupe=sum([cout_groupe(id_groupe) for id_groupe in group_set])

    ###############################################
    ####### Début des dj

    #base_brute = filtrage_par_ratio_prix(base_brute)
    #base_brute = filtrage_par_dj_par_presta(base_brute)

    # Calcul du nombre de dj remboursées
    temp = base_brute[period].multiply(base_brute['dj_par_presta'], axis=0)
    temp.columns = period_nb_dj_rembourse
    base_brute[period_nb_dj_rembourse] = temp
    
    for date in period:
        string_prix = 'prix_' + str(date)
        string_prix_par_dj = 'prix_par_dj_' + str(date)
        base_brute[string_prix_par_dj] = base_brute[string_prix] / base_brute['dj_par_presta']


    ####### Fin des dj
    #################################################
    return base_brute


def selection(table):
    '''Ajoute les champs selector et classe_a_conserver dans base_brute'''  
    '''selector dépend des criteres choisis'''
    '''classe_a_conserver montre les classes qui sont assez complètes après selector'''           
      
    for name in ['selector', 'classe_a_conserver', 'SA_defini', 'une_seule_base', 'cip_sel']:
        try :
            table = table.drop(name, axis = 1)
        except:
            pass

    # On retire les groupes qui ont beaucoup trop de substances
    # On travaillera plus loin sur les autres
#    poche = table['Label_presta'].str.contains('poche').sum()
    nb_subs = table.groupby('CIP')['Nom_Substance'].nunique()
    trop_substance = nb_subs[nb_subs > 3].index
    trop_substance_atc4 = table.loc[table['CIP'].isin(trop_substance), 'CODE_ATC_4']
    to_remove = table['CODE_ATC_4'].isin(trop_substance_atc4)
    nb_atc4 = table['CODE_ATC_4'].nunique()
    nb_atc4_removed = trop_substance_atc4.nunique()
    print("on retire " + str(nb_atc4_removed) + " groupe atc4 parmi " + 
            str(nb_atc4) + " parce qu'on a trop de substances parfois")
    table = table[~to_remove]
    
    # Calcul du nombre de lignes pour chaque CIP
    try:
        table['nb_CIP']
    except:
        nb_CIP = table.groupby('CIP').apply(len)
        nb_CIP = pd.DataFrame(nb_CIP, columns = ['nb_CIP'])
        table = pd.merge(table, nb_CIP, left_on = 'CIP', right_index = True, how = 'left')
        
    # Calcule le nombre de substances différentes pour chaque CIP
    try:
        table['nb_substances']
    except:
        nb_substances = table.groupby('CIP')['Code_Substance'].apply(lambda x: x.nunique()) # Nombre de substances differentes dans : le cip
        nb_substances = pd.DataFrame(nb_substances)
        nb_substances.columns = ['nb_substances'] # Il y a un bug à cause de l'attribut name de la série
        table = pd.merge(table, nb_substances, left_on = 'CIP', right_index = True, how = 'left')


    # Résolution des CIP multiples
#    multi_cip = table.groupby('CIP').filter(lambda x: len(x) > 1)
    multi_cip = table.groupby('CIP').filter(lambda x: x['Nom_Substance'].nunique() > 1)
    # on fait ici, une séléction apr ASMR, qu'il faudra retirer à terme
    # TODO: voir la séléction d'ASMR avant
    # on séléctionne donc une ligne par CIP/substance
    multi_cip = multi_cip.groupby(['CIP','Nom_Substance']).first().reset_index()
    # on retire quand on ne connait pas la substance
    multi_cip = multi_cip[multi_cip['Nom_Substance'].notnull()]
    
    

    print( " au début on a \n", multi_cip['CIP'].value_counts().value_counts())
#    On regarde si le nom de substance contient le mot Base et si celui çi est unique pour le CIP
#   Selecteur : On sélectionne les substances définies comme "de base"
    
    multi_cip['Substance_BASE'] = multi_cip['Nom_Substance'].str.contains(' BASE')
    multi_cip['Substance_BASE'].fillna(False, inplace = True)
#   Selecteur : On compte qu'il n'y a qu'un seul "de base" pour un un unique CIP
    
    def _select_BASE(x):
        return (sum(x['Substance_BASE']) == 1)
            
    selector_is_Base = multi_cip.groupby('CIP').apply(_select_BASE)
    selector_is_Base = selector_is_Base[selector_is_Base]
    anti_select = (multi_cip['CIP'].isin(selector_is_Base.index)) & \
                            (~multi_cip['Substance_BASE'])
    multi_cip = multi_cip[~anti_select]
    
    print( " après select BASE, on a  \n", multi_cip['CIP'].value_counts().value_counts())
    
    
    multi_cip = multi_cip['Label_presta'].str.contains('oche')
    multi_cip.groupby('CIP')['Nom_Substance'].nunique()
    multi_cip['CIP'].value_counts().value_counts()
    
    
    
    prob = multi_cip['CIP'].value_counts() > 10
    prob = multi_cip['CIP'].value_counts()[prob].index.tolist()
    prob_table = multi_cip[multi_cip['CIP'].isin(prob)]
    

#   Selecteur : On regarde s'il y a une unique SA pour le CIP
    selector_SA_defini = table.groupby('CIP')['Nature_Composant'].apply(lambda x: (sum(x == 'SA') == 1) & x.notnull().all())
    selector_SA_defini = pd.DataFrame(selector_SA_defini)
    selector_SA_defini.columns = ['SA_defini']
    table = table.merge(selector_SA_defini, left_on = 'CIP', right_index = True, how = 'left')
    selector_is_SA = table['SA_defini'] & (table['Nature_Composant'] == 'SA')

    # On fait l'union des selecteurs
    selector = (table['nb_CIP'] == 1) | selector_is_Base | selector_is_SA
    
    
#    # On selectionne les lignes à éliminer car le CIP est déjà dedans
    cip_sel = pd.DataFrame(True, index = table.loc[selector, 'CIP'], columns = ['cip_sel']) # True si le CIP est déjà dedans
    table = table.merge(cip_sel, left_on = 'CIP', right_index = True, how = 'left')
    table['cip_sel'] = table['cip_sel'].fillna(False)
    cip_sel = table['cip_sel']
    
    print 'nb cip sel is : ' + str(cip_sel.sum())
    
    # TODO: mettre pivot table pour conserver tous les changements de dates d'ASMR
    tab_copy = table[~cip_sel]
    # Var veut dire variation
    var_in_substance = (tab_copy.groupby('CIP')['Code_Substance'].apply(lambda x: x.nunique()) > 1) & tab_copy.groupby('CIP')['Code_Substance'].apply(lambda x: x.notnull().all())
    var_in_substance = pd.DataFrame(var_in_substance)
    var_in_substance.columns = ['var_in_substance']
    var_in_ASMR = (tab_copy.groupby('CIP')['Valeur_ASMR'].apply(lambda x: x.nunique()) > 1) & (tab_copy.groupby('CIP')['Valeur_ASMR'].apply(lambda x: x.notnull().all()))
    var_in_ASMR = pd.DataFrame(var_in_ASMR)
    var_in_ASMR.columns = ['var_in_ASMR']
    
    tab_copy = tab_copy.merge(var_in_substance, left_on = 'CIP', right_index = True, how = 'left')
    tab_copy = tab_copy.merge(var_in_ASMR, left_on = 'CIP', right_index = True, how = 'left')
    
    print 'xxxxxxxxxxxxxxx'
    print tab_copy['var_in_substance'].value_counts()
    print 'yyyyyyyyyyyyyy'
    print tab_copy['var_in_ASMR'].value_counts()
    print 'zzzzzzzzzzzzzz'
    
#    selector_ASMR = tab_copy[~tab_copy['var_in_substance'] & tab_copy['var_in_ASMR']].groupby('CIP').apply(first_largest_asmr).reset_index()
#    selector_ASMR = pd.DataFrame(selector_ASMR['Valeur_ASMR'], index = list(selector_ASMR['CIP']), columns = ['selector_ASMR'])
#    selector_ASMR.columns = ['selector_ASMR']
#    table = table.merge(selector_ASMR, left_on = 'CIP', right_index = True, how = 'left')
#    table['selector_ASMR'].fillna(False, inplace = True)
#    selector_ASMR = table['selector_ASMR']
#    
#    # TODO: Ca ne marche pas !!!
#    print selector_ASMR
#    print selector_ASMR.value_counts()
#    print selector
#    
#    selector = selector | selector_ASMR


#    table = table.drop('nb_CIP', axis = 1)
#    table = table.drop('nb_substances', axis = 1)    
    
    table['selector'] = selector

    ################################################################################

    medicaments_par_classe_avt = table.groupby('CODE_ATC_4')['CIP'].nunique()
    boites_vendues_par_classe_avt = table.groupby('CODE_ATC_4')[period].sum().sum(axis=1)

    medicaments_par_classe_apr = table[selector].groupby('CODE_ATC_4')['CIP'].nunique()
    boites_vendues_par_classe_apr = table[selector].groupby('CODE_ATC_4')[period].sum().sum(axis = 1)
    classes_a_conserver_nb = (medicaments_par_classe_apr/medicaments_par_classe_avt)
    classes_a_conserver_nb = classes_a_conserver_nb > 0.8
    
    classes_a_conserver_ventes = (boites_vendues_par_classe_apr / boites_vendues_par_classe_avt)
    classes_a_conserver_ventes = classes_a_conserver_ventes > 0.8

    
    classes_a_conserver = classes_a_conserver_nb & classes_a_conserver_ventes
    classes_a_conserver = pd.DataFrame(classes_a_conserver, columns = ['classe_a_conserver'])    
    
    ######## Fin : filtrage pour les classes assez complètes
    ##################################################    
    
    
    table = pd.merge(table, classes_a_conserver, left_on = 'CODE_ATC_4', right_index = True, how = 'left')
    return table

#
#'''Ecart de prix par dosage par groupe/classe'''
#date = 201406
#maxim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].max()
#minim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].min()
#a = maxim/minim
#
#'''Ecart de dj par presta par groupe/classe'''
#maxim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].max()
#minim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].min()
#a = maxim/minim
#
#rapport_max_prix = a.sort()
    
def first_largest_asmr(serie):
    ### ATTENTION : il y a le risque d'avoir plusieurs CIP sélectionnés
    for x in ['I', 'II', 'III', 'IV', 'V']:
        if x in serie['Valeur_ASMR']:
            return serie['Valeur_ASMR'] == x
    return serie['Valeur_ASMR'] == 'I'

def difference(table): #saved as test
    '''Renvoie la liste des champs qui changent'''
    a = table.iloc[:, :34].apply(lambda x: x.nunique())
    sel = a > 1
    return list(a.index[sel])
    
if __name__ == '__main__':
    period, period_prix, period_prix_par_dosage, period_nb_dj_rembourse, period_prix_par_dj = all_periods(base_brute)

#    Compter les CIP qui ont plus d'une substance
#    base_brute.groupby('CIP')['nb_substances'].apply(lambda x: any(x>1)).sum() : vaut 2342