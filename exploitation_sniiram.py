# -*- coding:utf-8 -*-
'''
Created on 5 août 2014

@author: tvialette, aeidelman, lbouloc
'''

import numpy as np
import pandas as pd
from pandas import DataFrame
import re
import matplotlib.pyplot as plt

import display_and_graphs as dg
from load_data.load import load_all
from load_data.atc_ddd import load_atc_ddd
from display_and_graphs import info_display
# Numéro de la mise à jour pour la base medicaments.gouv
maj_gouv = 'maj_20140915122241'
# parametres du calcul
# Ne marche pas si la liste inclut 'CIS'
info_utiles_from_gouv = ['CIP7', 'CIP13', 'Nom', 'Id_Groupe', 'Prix', 'Titulaires', 'Num_Europe',
                         'Code_Substance', 'Nom_Substance', 'Libelle_ASMR', 'Type',
                         'Date_declar_commerc', 'Date_AMM', 'Taux_rembours',
                         'indic_droit_rembours', 'Statu_admin_presta',
                         'Ref_Dosage', 'Dosage', 'Label_presta','Valeur_ASMR',
                         'nb_Ref_Dosage',
                         'premiere_vente', 'derniere_vente']
info_utiles_from_cnamts = ['CIP', 'CODE_ATC', 'LABO', 'DOSAGE_SA', 'UNITE_SA', 'NB_UNITES'] #LABO

info_utiles_from_atc_ddd = ['CODE_ATC', 'CHEMICAL_SUBSTANCE', 'DDD', 'UNITE', 'MODE']

# Evite de recharger si on a déjà chargé la base.

def cip_unique(table):
    table['cip_unique'] = pd.Series([False] * len(table), index = table.index)
    code_substance_present = []
    i=0
    for cip in set(table['CIP13']):
        i+=1
        if i%100 == 0:
            print i
        test = table['CIP13'] == cip
        #S'il y a plus d'un médicament de même CIP13 dans la base
        if sum(test) != 1:
            trouve = False
            #Pour toutes les médicaments de même CIP
            for index in table[test].index:
                code = table.loc[index,'Code_Substance']
                # On cherche d'abord s'il y en a un dont la substance est déjà parmi les médicaments séléctionnés
                if code in code_substance_present:
                    table.loc[index, 'cip_unique'] = True
                    trouve = True
                    break
            # Si on n'en trouve pas, on rajoute le premier de la liste aux médicaments séléctionnés
            if trouve == False:
                table.loc[index, 'cip_unique'] = True
        else:
            table.loc[table['CIP13'] == cip, 'cip_unique'] = True
    return table

def groupe_substance_unique(table):
    group_select = table.groupby('Id_Groupe').apply(lambda x: len(set(x['Code_Substance'])) == 1)
    group_select_set = list(set(group_select.index[group_select]))
    table = table[table['Id_Groupe'].isin(group_select_set)]
    return table


def calcul_prix_par_dosage_test(table):
    '''ATTENTION : ne fait pas ce qui est indiqué dans le titre'''
    '''Calul du prix par dosage a une date précise pour les données issues de la base medic_gouv et cnamts'''
    print 'actuellement dans calcul_prix_par_dosage'
    ### Pour la base medic_gouv 
    table.loc[base_brute['Dosage'] == 'qs','Dosage'] = 0 #Cas particulier
    table['Dosage_num'] = table['Dosage'].apply(lambda x: re.findall('\d*\.?\d+',str(x))[0])
    table['Dosage_num'] = table['Dosage_num'].astype(float)    
    table['dosage_par_prestation_medic_gouv'] = table['Dosage_num'] * table['nb_ref_in_label_medic_gouv']
    table['dosage_par_prestation_medic_gouv'].replace(0, np.nan, inplace=True)
    ### Pour la base cnamts
    table['dosage_par_prestation_cnamts'] = table['DOSAGE_SA']*table['NB_UNITES']
    
    return table

def calcul_prix_par_dj_par_presta(table):
    '''Calcul du prix_par_dj_par_presta'''
    for date in period:
        string_prix = 'prix_' + str(date)
        string_prix_par_dj = 'prix_par_dj_' + str(date)
        table[string_prix_par_dj] = table[string_prix] / table['dj_par_presta']
    return table

def prix_par_dosage_test(table):
    date=201406
    string = 'prix_' + str(date)
    table['prix_par_dosage_test_cnamts'] = [float(x) / float(y) for x,y in zip(table[string], table['dosage_par_prestation_cnamts'])]
    table['prix_par_dosage_test_medic_gouv'] = [float(x) / float(y) for x,y in zip(table[string], table['dosage_par_prestation_medic_gouv'])]
    return table

def choix_de_la_base(table):
    '''Indique s'il faut conserver les valeurs du cnamts ou de médic. gouv pour chaque médicament'''
    print 'actuellement dans choix_de_la_base'
    table['base_choisie'] = pd.Series()
    
#    prix_nul = table['prix_par_dosage_test_medic_gouv'] == 0
#    table.loc[prix_nul, 'prix_par_dosage_test_medic_gouv'] = \
#    table.loc[prix_nul, 'prix_par_dosage_test_medic_gouv'].apply(lambda x: np.nan)

    global taille_du_groupe
    global prix_moyen_par_groupe_medic_gouv
    global prix_moyen_par_groupe_cnamts
    global variance_par_groupe_medic_gouv
    global variance_par_groupe_cnamts
    grp = table.groupby('group')
    taille_du_groupe = grp.size()
    
    table = prix_par_dosage_test(table)  

    prix_moyen_par_groupe_medic_gouv = grp['prix_par_dosage_test_medic_gouv'].sum().div(taille_du_groupe)#.apply(lambda x: x*x) #Il s'agit en fait du carré
    prix_moyen_par_groupe_cnamts = grp['prix_par_dosage_test_cnamts'].sum().div(taille_du_groupe)#.apply(lambda x: x*x) #Il s'agit en fait du carré
  
    prix_var_norm_par_groupe_medic_gouv = table.groupby('group')['prix_par_dosage_test_medic_gouv'].std().div(prix_moyen_par_groupe_medic_gouv)
    prix_var_norm_par_groupe_cnamts = table.groupby('group')['prix_par_dosage_test_cnamts'].std().div(prix_moyen_par_groupe_cnamts)

    #On conserve les prix dans la même base si on a tous les prix d'un groupe
    a = prix_moyen_par_groupe_medic_gouv.notnull()
    b = prix_moyen_par_groupe_cnamts.notnull()
    
    #Pour chaque groupe
    i = 0
    for group in set(table['group']):
        if i%100 == 0:
            print str(float(i) / float(len(set(table['group'])))) + '%'
        i=i+1
        # Dans le cas où les valeurs de prix pour tout le groupe dans les deux base
        if a[group] and b[group]:
            # On garde le groupe avec la variance normalisée la plus faible
            if prix_var_norm_par_groupe_medic_gouv[group] < prix_var_norm_par_groupe_cnamts[group]:
                table.loc[base_brute['group'] == group,'base_choisie'] = 'medic_gouv'
            else:
                table.loc[base_brute['group'] == group,'base_choisie'] = 'cnamts'
        elif a[group]:
            table.loc[base_brute['group'] == group,'base_choisie'] = 'medic_gouv'
        elif b[group]:
            table.loc[base_brute['group'] == group,'base_choisie'] = 'cnamts'
        else:
            #Enfin, si on a deux valeurs différentes, on calcule le prix relativement à la moyenne du groupe.
            # Le prix "moyen" est en réalité la somme des prix mais ca n'a pas de conséquences
            table[table['base_choisie'].isnull()] = table[table['base_choisie'].isnull()].apply(lambda x: choix_de_la_base_lambda1(x), axis=1)
            #print('f')
            table[table['base_choisie'].isnull()] = table[table['base_choisie'].isnull()].apply(lambda x: choix_de_la_base_lambda2(x), axis=1)
    return table

def choix_de_la_base_lambda1(ligne):
    if ligne['prix_par_dosage_test_medic_gouv'] == 0:
        ligne['prix_par_dosage_test_medic_gouv'] = np.nan
    if sum(ligne[['prix_par_dosage_test_medic_gouv', 'prix_par_dosage_test_cnamts']].isnull()) == 2:
        ligne['base_choisie'] = 'Aucune'
    elif sum(ligne[['prix_par_dosage_test_medic_gouv', 'prix_par_dosage_test_cnamts']].isnull()) == 1:
        if np.isnan(ligne['prix_par_dosage_test_medic_gouv']):
            ligne['base_choisie'] = 'cnamts'
        else:
            ligne['base_choisie'] = 'medic_gouv'
    elif ligne['prix_par_dosage_test_medic_gouv'] == ligne['prix_par_dosage_test_cnamts']:
        ligne['base_choisie'] = 'medic_gouv'
    return ligne

def choix_de_la_base_lambda2(ligne):
    # On choisit la base qui donne un ratio le plus petit possible (équivalent écart à la moyenne)
    #print (prix_moyen_par_groupe_medic_gouv[ligne['Id_Groupe']])
    #if taille_du_groupe[ligne['group']] <=2:
    #    ligne['base_choisie'] = 'medic_gouv'

    ratio_medic_gouv = ligne['prix_par_dosage_test_medic_gouv'] / float(prix_moyen_par_groupe_medic_gouv[ligne['group']])
    ratio_cnamts = ligne['prix_par_dosage_test_cnamts'] / float(prix_moyen_par_groupe_cnamts[ligne['group']])
    if ratio_medic_gouv < 1:
        ratio_medic_gouv = float(1) / ratio_medic_gouv
    if ratio_cnamts < 1:
        ratio_cnamts = float(1) / ratio_cnamts

    if ratio_medic_gouv < ratio_cnamts:
        ligne['base_choisie'] = 'medic_gouv'
    else:
        ligne['base_choisie'] = 'cnamts'
    return ligne

def get_index(date):
    '''prend comme entrée une date au format YYYYMM et renvoie l'index numérique de cette date dans périod'''
    output = (int(date)/100-2003)*12 + int(date)%100-1
    return output

def rewrite_period_prix(ligne):
    '''sert dans la fonciont preparation_base_period_prix'''
    index = get_index(ligne['premiere_vente'])
    for i in range(index):
        ligne[period_prix_par_dosage[i]]=np.nan
        ligne[period_prix[i]]=np.nan
    return ligne

'''Modifient les prix pour une meilleure visualisation sur les graphs'''
def preparation_base_period_prix(table):
    '''Remplace par des nan les valeurs prix avant que le médicament soit vendu (pour qu'il n'apparaisse pas dans les graphs)'''
    print 'actuellement dans preparation_base_period_prix'
    table['premiere_vente'] = table['premiere_vente'].fillna(200301)
    table = table.apply(lambda x: rewrite_period_prix(x), axis = 1)
    return table

'''Determiner pour chaque groupe la date du premier générique'''

def date_generique(table_groupe):
    if sum(table_groupe['Type'] == 1) == 0:
        return 201406
    else:
        value = table_groupe.loc[table_groupe['Type'] == 1, 'premiere_vente'].min()
        if np.isnan(value):
            return 201406
        else:
            return value

def atc_niv_4(table):
    table['CODE_ATC_4'] = table['CODE_ATC'].apply(lambda x: x[:5])
    return table

#def cout(dosage, prix_par_dosage):
#    #print dosage
#    assert len(dosage) == len (prix_par_dosage)
#    dosage.index = period
#    prix_par_dosage.index = period
#    return (dosage*prix_par_dosage).sum()
    
def cout(table):
    prix = table[period_prix]
    prix.columns = period
    vol = table[period]
    cout = vol * prix
    taux = table['Taux_rembours'].apply(taux_rembours_float)
    cout = cout.apply(lambda x: x * taux)
    return cout

def filtrage_par_ratio_prix(table):
    '''Fonction qui réduit la base pour avoir des cas dont on est certain'''
    print 'actuellement dans filtrage_par_ratio_prix'    

    max_ratio = 7
    date=201406

    '''On garde les groupes avec un ratio raisonnable'''
    maxim = table.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].max()
    minim = table.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].min()
    a = maxim/minim
    table = table[table['Id_Groupe'].apply(lambda x: a[x]<max_ratio)]
    
    return table
    
def filtrage_par_dj_par_presta(table):
    '''Fonction qui réduit la base pour avoir des cas dont on est certain'''
    print 'actuellement dans filtrage_par_dj_par_presta'
    table = table[table['dj_par_presta'].notnull()]
    table = table[table['dj_par_presta'] >= 1]
    table = table[table['dj_par_presta'] <= 360]
    
    '''On ne garde qu'une ligne par médicament'''
    table = table.drop_duplicates(subset = 'CIP7')
    
    print 'On a désormais : ' + str(len(table)) + ' medicaments uniques'
    
    '''On garde les CIP7 uniques ou qui ont un même prix par dosage'''
#    select = table.groupby('CIP7').apply(lambda x: x['prix_par_dosage_201406'].nunique() == 1)
#    table = table.groupby('CIP7').apply(lambda x: x.iloc[0,:])
#    table = table[select]
    
    '''On ne garde que les CIP7 uniques'''
    #table = groupe_substance_unique(table)        
    
    return table    
    

'''Vérifier les substances communes à tous les groupes de la classe'''
#def intersect_group(table_class):
#    all_substances = table_class['Code_Substance'].unique()
#    for groupe in table_class['Id_Groupe'].unique():
#        temp = table_class[table_class['Id_Groupe'] == groupe]
#        substances_groupe = temp['Code_Substance'].unique()
#        all_substances = np.intersect1d(all_substances, substances_groupe)
#    return all_substances
    

def calcul_dj_par_presta(table, atc_ddd):
    '''Calcul de la dose journalière par prestation : ATTENTION : requiert le champ base_choisie'''
    print 'actuellement dans calcul_dj_par_presta'
    if not 'dj_par_presta' in table.columns:
        table['dj_par_presta'] = np.nan
    # Calcul de la dj par presta pour les medicaments du cnamts
    selector = table['base_choisie'] == 'cnamts'
    table.loc[selector, 'dj_par_presta'] = table.loc[selector, :].apply(lambda ligne: calcul_ddd_cnamts_ligne(ligne, atc_ddd), axis =1)
    # Calcul de la dj par presta pour les medicaments de medic gouv avec une seule substance
    cip_uniques = table.groupby('CIP7')['Code_Substance'].nunique() == 1
    selector = table.apply(lambda x: cip_uniques[x['CIP7']] and x['base_choisie'] == 'medic_gouv', axis = 1)
    table.loc[selector, 'dj_par_presta'] = table[selector].apply(lambda ligne: calcul_ddd_medic_gouv_substance_unique_ligne(ligne, atc_ddd), axis = 1)
    return table
    
def calcul_ddd_cnamts_ligne(ligne, atc_ddd):
    '''Calcul de la ddd pour les medicaments qu'on a pris de la cnamts'''

    code_atc = ligne['CODE_ATC']
    selector = atc_ddd['CODE_ATC'] == str(code_atc)
    atc_ddd_restreint = atc_ddd.loc[selector, :]
    nunique_code_atc = sum(selector)
    '''On vérifie que le dosage est bien au format nombre unité'''
    dosage = ligne['DOSAGE_SA']
    unite = str(ligne['UNITE_SA'])
    nb_unites = ligne['NB_UNITES']  
    
    return calcul_ddd(ligne, atc_ddd_restreint, code_atc, dosage, unite, nb_unites, nunique_code_atc)

def calcul_ddd_medic_gouv_substance_unique_ligne(ligne, atc_ddd):
    '''Calcul de la ddd pour les medicaments qu'on a pris de medic_gouv'''
    code_atc = ligne['CODE_ATC']
    selector = atc_ddd['CODE_ATC'] == str(code_atc)
    atc_ddd_restreint = atc_ddd.loc[selector, :]
    nunique_code_atc = sum(selector)
    '''On vérifie que le dosage est bien au format nombre unité'''
    dosage_list = ligne['Dosage'].split()
    dosage = float(dosage_list[0])
    unite = dosage_list[1]
    nb_unites = ligne['nb_ref_in_label_medic_gouv']
    
    if len(dosage_list) != 2:
        return np.nan
    else:
        return calcul_ddd(ligne, atc_ddd_restreint, code_atc, dosage, unite, nb_unites, nunique_code_atc)


def calcul_ddd(ligne, atc_ddd_restreint, code_atc, dosage, unite, nb_unites, nunique_code_atc):
    
    list_O = ['compr', 'lule', 'capsule', 'flacon']
    list_P = ['seringue']
    
    '''Si la classe n'est pas présente dans la table des ddd'''
    if nunique_code_atc == 0:
        return (np.nan)
        '''Si le code est présent une seule fois dans la base des ddd, on a pas de doute'''
    elif nunique_code_atc == 1:
        '''On vérifie que les unités correspondent bien'''
        if unite.upper() == str(atc_ddd_restreint['UNITE'].iloc[0]):
            nb_dj_par_prestation = dosage*nb_unites / atc_ddd_restreint['DDD'].iloc[0]
            return nb_dj_par_prestation
        else:
            return np.nan
    elif nunique_code_atc == 2 and atc_ddd_restreint['MODE'].nunique() == 2:
        
        if any([x in ligne['Label_presta'] for x in list_O]) and 'O' in list(atc_ddd_restreint['MODE'].apply(str)): 
            diviseur = atc_ddd_restreint.loc[atc_ddd_restreint['MODE'] == 'O', 'DDD'].iloc[0]
            if unite.upper() == str(atc_ddd_restreint.loc[atc_ddd_restreint['MODE'] == 'O', 'UNITE'].iloc[0]):
                nb_dj_par_prestation = dosage*nb_unites / diviseur
                return nb_dj_par_prestation
            else:
                return np.nan
        
        elif any([x in ligne['Label_presta'] for x in list_P]) and 'P' in list(atc_ddd_restreint['MODE'].apply(str)):
            diviseur = atc_ddd_restreint.loc[atc_ddd_restreint['MODE'] == 'P', 'DDD'].iloc[0]
            if unite.upper() == str(atc_ddd_restreint.loc[list(atc_ddd_restreint['MODE'] == 'O'), 'UNITE'].iloc[0]):
                nb_dj_par_prestation = dosage*nb_unites / diviseur
                return nb_dj_par_prestation
            else:
                return np.nan
        else:
            return np.nan
    else:
            return np.nan


def new_type(base_brute, ligne):
    '''renvoie 3 si le groupe n'a pas encore de générique'''
    n = base_brute.loc[base_brute['Id_Groupe'] == ligne['Id_Groupe'], 'Type'].nunique()
    if n == 1:
            return 4
    else:
        return ligne['Type']
        

        
'''Load de la base brute et définition de variables essentielles'''
try:
    base_bruto
except:
    base_bruto = load_all(from_gouv=info_utiles_from_gouv, maj_gouv=maj_gouv,
                      from_cnamts=info_utiles_from_cnamts)
    atc_ddd = load_atc_ddd(info_utiles_from_atc_ddd)           
                      
    print(base_bruto['prix_201406'])

    period = [int(x) for x in base_bruto.columns if isinstance(x, long)]
    #period_prix renvoie vers les colonnes qui décrivent le prix des medicaments
    period_prix = ['prix_' + str(x) for x in period]
    period_prix_par_dosage = ['prix_par_dosage_' + str(date) for date in period]
    period_nb_dj_rembourse = ['nb_dj_rembourse_' + str(date) for date in period]
    period_prix_par_dj = ['prix_par_dj_' + str(date) for date in period]


    ##### On fait maintenant l'exploitation à partir de groupe :
    ### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
    ### Exemple : Id_groupe et is_princeps
    base_bruto['group'] = base_bruto['Id_Groupe']
    base_bruto['role'] = base_bruto['Type'] == 0 # a=b==0 --> a is true if b==0 // True pour le princeps

    '''Filtrage de base_bruto'''
    #On conserve sulement les medicaments dont on connait le groupe generique
    base_bruto = base_bruto.loc[base_bruto['group'].notnull(), :]
    #On ne conserve que les lignes pour lesquelles on connait le dosage
    base_bruto = base_bruto[base_bruto['Dosage'].notnull()]
    # On enlève les lignes sans code ATC
    base_bruto = base_bruto[base_bruto['CODE_ATC'].notnull()]
    
    base_bruto.loc[:, 'group'] = base_bruto.loc[:, 'group'].astype(int)
    base_bruto.loc[:, 'role'] = base_bruto.loc[:, 'role'].astype(bool) #pour faire planter si on a trois groupes...

    # quelques infos pour faire joli
    nombre_cip = len(base_bruto['CIP13'].unique())
    taille_base_bruto = len(base_bruto)
    print "La base base_bruto provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_bruto) + \
        " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."

    ### Date de chute du brevet, se généralise en "modification du groupe" ?
    ## On a deux méthodes concurrentes
    grp = base_bruto.groupby('group')

    #Calcul de la date de chute de brevet (2 methodes)
    chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())
    chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
    #base_bruto['chute_brevet']=chute_brevet1

    

    base_bruto.rename(columns={'nb_Ref_Dosage': 'nb_ref_in_label_medic_gouv'},
                      inplace=True)
                      
    base_bruto['new_type'] = base_bruto.apply(lambda x: new_type(base_bruto, x), axis=1)
    print 'len base_bruto is : ' + str(len(base_bruto))


    #Supprime les doublons dans base_bruto en séléctionnant en priorité la substance qui est déjà présente

base_brute = base_bruto.copy()
base_brute = atc_niv_4(base_brute)
medicaments_par_classe_avt = base_brute.groupby('CODE_ATC_4')['CIP7'].nunique()
boites_vendues_par_classe_avt = base_brute.groupby('CODE_ATC_4')[period].sum().sum(axis = 1)

#base_brute = base_brute = groupe_substance_unique(base_brute)

#on veut les groupes avec à la fois des génériques et des princeps
#(il y a au moins un princeps) & (il y a au moins un non princeps) & (le brevet ne tombe pas au début des samples(i.e. avant le débbut de l'échantillon))
cond = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0) & (chute_brevet1 > period[0])

period_str = [str(t) for t in period]

'''Calcul du prix par dosage : necessaire pour la suite, pour le filtrage'''
base_brute = calcul_prix_par_dosage_test(base_brute)

base_brute = choix_de_la_base(base_brute)
base_brute['dosage_par_prestation'] = np.nan
base_brute = base_brute[base_brute['base_choisie'] != 'Aucune'] # On élimine les médicaments pour lesquels on n'a pas de dosage

print 'Effectue le choix du dosage'
base_brute['dosage_par_prestation'] = base_brute['dosage_par_prestation_cnamts']
base_medic = base_brute['base_choisie'] == 'medic_gouv'
base_brute.loc[base_medic, 'dosage_par_prestation'] = base_brute.loc[base_medic, 'dosage_par_prestation_medic_gouv']


#ATTENTION : Modifie la base_brute
base_brute = base_brute.loc[(base_brute['dosage_par_prestation'] != 0)]


#Calcul du prix par dosage pour chaque médicament
base_brute[period_prix_par_dosage] = base_brute.apply(lambda x: x[period_prix].divide(x['dosage_par_prestation']), axis=1)


'''Calcul du couts des médicaments d ASMR V plus chers'''
codes_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','CODE_ATC']))
group_set = list(set(base_brute.loc[base_brute['Valeur_ASMR']=='V','Id_Groupe']))
#cout_total_class=sum([cout_classe(code_atc) for code_atc in codes_set])
#cout_total_groupe=sum([cout_groupe(id_groupe) for id_groupe in group_set])

###############################################
####### Début des dj

base_brute = filtrage_par_ratio_prix(base_brute)
base_brute = calcul_dj_par_presta(base_brute, atc_ddd)
base_brute = filtrage_par_dj_par_presta(base_brute)

# Calcul du nombre de dj remboursées
test = base_brute.apply(lambda x: x.loc[period]*x.loc['dj_par_presta'], axis=1)
test.columns = period_nb_dj_rembourse
base_brute[period_nb_dj_rembourse] = test

# Calcul du prix par dj_par_presta
base_brute = calcul_prix_par_dj_par_presta(base_brute)

####### Fin des dj
#################################################



###############################################
####### Début : filtrage pour les classes assez complètes
medicaments_par_classe_apr = base_brute.groupby('CODE_ATC_4')['CIP7'].nunique()
boites_vendues_par_classe_apr = base_brute.groupby('CODE_ATC_4')[period].sum().sum(axis = 1)

classes_a_conserver_nb = (medicaments_par_classe_apr/medicaments_par_classe_avt)
classes_a_conserver_nb = classes_a_conserver_nb > 0.7

classes_a_conserver_ventes = (boites_vendues_par_classe_apr/boites_vendues_par_classe_avt)
classes_a_conserver_ventes = classes_a_conserver_ventes > 0.7

classes_a_conserver = classes_a_conserver_nb & classes_a_conserver_ventes
classes_a_conserver = [i for i in classes_a_conserver.index if classes_a_conserver[i]]
base_brute = base_brute[base_brute['CODE_ATC_4'].apply(lambda x: x in classes_a_conserver)]

print 'apres elimination des classes trop incomplètes, on a : ' + str(len(base_brute)) + ' lignes'
####### Fin : filtrage pour les classes assez complètes
#################################################


'''Ecart de prix par dosage par groupe/classe'''
date=201406
maxim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].max()
minim = base_brute.groupby(['Id_Groupe'])['prix_par_dosage_' + str(date)].min()
a = maxim/minim

'''Ecart de dj par presta par groupe/classe'''
maxim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].max()
minim = base_brute.groupby(['CODE_ATC'])['dj_par_presta'].min()
a = maxim/minim

rapport_max_prix = a.sort()

date_generication_groupe = base_brute.groupby('Id_Groupe').apply(lambda x: date_generique(x))




